Input token: 304
Output token: 637
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', '.', '.', '.', 'd', '.', '.', '.', '.', 'd', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', 'd', 'd', 'd', 'd', 'd', 'd', '.']

Example_2:
input: ['.', 'f', '.', '.', '.', '.', '.', '.', 'f', '.', '.', '.', '.', '.', '.']
output: ['.', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'h', '.', '.', 'h', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'h', 'h', 'h', 'h', '.']

Test case:
input: ['.', '.', '.', 'g', '.', '.', 'g', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', 'g', 'g', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.']
"""
from typing import List, Optional
import collections


class Solution(object):
    def reverseWords(self, s: str) -> None:
        """
        :type s: str
        :rtype: None
        """
        if not isinstance(s, str):
            return
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复杂度为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终再重新组合。
        words = s.split()
        for word in words:
            self._reverseWord(word)
            
        # 使用双指针，时间复杂度为 O(n)，空间复杂度为 O(1)。
        # 先将字符串分割成多个单词，然后在两个指针之间交换位置，直到所有的单词都被移动过来。
        i = j = len(words) - 1
        while i >= 0 or j < len(words):
            if i > 0 and j < len(words):
                tmp = words[i]
                words[i], words[j] = words[j], tmp
                
            i -= 1
            j += 1
    
    def _reverseWord(self, word: str) -> None:
        """
        :type word: str
        :rtype: None
        """
        if not isinstance(word, str):
            return
        
        # 使用双指针，时间复杂度为 O(n)，空间复杂度为 O(1)。
        # 首先判断当前单词是否已经完全反转过了，如果没有则需要反转，否则不需要反转。
        i = j = len(word) - 1
        while i >= 0 or j <= 0:
            if i >= 0 and j <= 0:
                break
            
            if word[i] == word[j]:
                continue
            
            tmp = word[i]
            word[i], word[j] = word[j], tmp
            
            i -= 1
            j += 1

################################################################

Solution:
['.', '.', '.', 'g', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.', '.']

