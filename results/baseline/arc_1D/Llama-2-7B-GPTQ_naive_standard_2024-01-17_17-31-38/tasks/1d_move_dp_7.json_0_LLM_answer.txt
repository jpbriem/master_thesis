Input token: 191
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'c', 'c', 'c', '.', '.', 'h']
output: ['.', '.', '.', 'c', 'c', 'c', 'h']

Example_2:
input: ['b', 'b', 'b', '.', '.', '.', 'h']
output: ['.', '.', '.', 'b', 'b', 'b', 'h']

Example_3:
input: ['c', 'c', 'c', '.', '.', '.', 'h']
output: ['.', '.', '.', 'c', 'c', 'c', 'h']

Test case:
input: ['d', 'd', 'd', '.', '.', '.', 'h']
################################################################

LLM answer:

output: ['.', '.', '.', 'd', 'd', 'd', 'h']
"""
import sys
from collections import deque, defaultdict

class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        
        if not isinstance(s, list) or len(s) == 0: return []
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复权为O(n)。
        # 先将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终返回所有的单词。
        words = s.split()
        reversed_words = []
        for word in words:
            reversed_word = ''
            for char in word:
                reversed_char = ord(char)-ord('a')+1
                if reversed_char > 96: continue
                
                reversed_word += chr(reversed_char)
            
            reversed_words.append(reversed_word)
        
        return reversed_words
    
    def reverseWords_II(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        
        if not isinstance(s, list) or len(s) == 0: return []
        
        # 使用双指针，时间复权为 O(n)，空间复权为 O(n)。
        # 首先判断是否需要切割，如果不需要切割直接返回原字符串，否则按照长度比较，若大于等于两边都需要切割，则切割；若小于，则不切割。
        # 在切割之前，记录当前位置，并且保存当前切割点的下标。
        # 在切割之后，将切割点的下标加入到切割点的左右两边，并将切割点的下标设置为 -1。
        # 再次判断是否需要切割，此时已经知道切割点的下标，因此可以更新切割点的下标，同时也能更新切割点的上下两边的下标。
        # 重复这样的过程，直到切割点的下标变为 -1，表示切割完毕。
        # 最后将切割点的下标设置为 0，并将切割点的上下两边的下标设置为 1，形成了新的字符串。
        # 注意：切割点的下标必须是正数，因此切割点的下标会从 0 开始计算。
        # 例如：
        # 输入：'abcd'
        # 输出：['acdb','adcb']
        # 时间复权： O(n)
        # 空间复权： O(n)
        # 思路：
        # 1、判断是否需要切割，若不需要切割直接返回原字符串，否则按照长度比较，若大于等于两边都需要切割，则切割；若小于，则不切割。
        # 2、在切割之前，记录当前位置，并且保存当前切割点的下标。
        # 3、在切割之后，将切割点的下标加入到切割点的左右两边，并将切割点的下标设置为 -1。
        # 4、再次
################################################################

Solution:
['.', '.', '.', 'd', 'd', 'd', 'h']

