Input token: 258
Output token: 900
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'h', '.', '.', '.', '.', '.', 'h', '.', '.', '.', '.']
output: ['.', 'h', 'h', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.']

Example_2:
input: ['.', 'b', '.', '.', 'b', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'b', 'b', 'b', 'b', '.', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', '.', '.', 'd', '.', 'd', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', 'd', 'd', 'd', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', '.', '.', '.', 'b', '.', '.', '.', '.', 'b', '.']
################################################################

LLM answer:

output: ['.', '.', '.', '.', '.', 'b', 'b', 'b', 'b', '.', '.', '.']
"""
from typing import List, Optional
import collections


class Solution(object):
    def reverseWords(self, s: str) -> None:
        """
        :type s: str
        :rtype: None
        """
        if not isinstance(s, str):
            return
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复权为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终再重新组合。
        words = s.split()
        for word in words:
            self._reverseWord(word)
            
        # 优化版本，时间复杂度为 O(n)，空间复权为 O(n)。
        # 先将字符串分割成多个单词，然后按照单词的长度从小到大排序，在这之前我们需要判断当前单词是否可以被反转，如果不能则直接返回，因此时间复杂度为 O(n)；
        # 然后根据排序结果来遍历，并对每个单词进行反转，最终再重新组合。
        sorted_words = list(sorted(set([w[0] for w in words]), key=len))
        for i in range(len(sorted_words)):
            self._reverseWord(sorted_words[i])
    
    def _reverseWord(self, word: str) -> None:
        """
        :type word: str
        :rtype: None
        """
        if len(word) == 0 or word[-1]!= '.':
            return
        
        # 使用双指针实现，时间复杂度为 O(n)，空间复权为 O(1)。
        # 首先定义两个变量，分别表示左边和右边，初始值设置为 -1，代表向前移动，因此时间复杂度为 O(n)；
        # 然后开始逐个元素进行比较，如果左边位于右边之前，则交换两者，否则保持原有状态，最终返回。
        left, right = -1, -1
        while left < len(word)-1:
            if word[left] > word[right]:
                left += 1
            else:
                right -= 1
                
            if left >= right:
                break
        
        # 使用切片实现，时间复杂度为 O(n)，空间复权为 O(1)。
        # 首先定义一个切片，然后遍历该切片中的所有元素，如果元素位于切片尾部，则交换该元素与切片头部，否则保持原有状态，最终返回。
        temp = []
        for index in reversed(range(len(word))):
            if index <= left+1:
                temp.append('.')
            elif index >= right:
                break
            else:
                temp.insert(index, word[index])
        
        word[:] = temp

################################################################

Solution:
['.', '.', '.', '.', '.', 'b', 'b', 'b', 'b', 'b', 'b', '.']

