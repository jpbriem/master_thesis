Input token: 307
Output token: 696
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', '.', 'f', 'f', 'f', 'f', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', 'f', 'f', 'f', 'f', '.', '.', '.']

Example_2:
input: ['.', 'b', 'b', 'b', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', 'b', 'b', 'b', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', '.', '.', '.']
"""

import sys
from collections import deque, defaultdict
from functools import reduce


def get_next(current):
    if current == "." or current in ["h", "f"]:
        return "."
    elif current == "b":
        return "h"
    else:
        raise ValueError("Invalid character")


def is_valid(characters):
    """Returns True if characters is a valid sequence of characters for the given language."""
    return all([get_next(c) not in (".", "h", "f") for c in characters])


def parse(string):
    """Parses string into a list of characters."""
    return [c for c in string]


def part_one(input_sequence):
    """Solution to Part One."""
    # Convert input sequence to a dictionary mapping each character to its index.
    char_to_index = {c: i + 1 for i, c in enumerate(input_sequence)}

    # Create an empty queue that will hold the next state of the game.
    next_state = []

    # Iterate through the input sequence, updating the next state as needed.
    for i, c in enumerate(input_sequence):
        if c == ".":
            continue
        if c == "h":
            next_state.append(".")
        elif c == "f":
            next_state.append("f")
        else:
            raise ValueError("Invalid character")

    # Return the final state of the game.
    return len(next_state) - 1


def part_two(input_sequence):
    """Solution to Part Two."""
    # Convert input sequence to a dictionary mapping each character to its index.
    char_to_index = {c: i + 1 for i, c in enumerate(input_sequence)}

    # Create an empty queue that will hold the next state of the game.
    next_state = []

    # Iterate through the input sequence, updating the next state as needed.
    for i, c in enumerate(input_sequence):
        if c == ".":
            continue
        if c == "h":
            next_state.append(".")
        elif c == "f":
            next_state.append("f")
        else:
            raise ValueError("Invalid character")

    # Return the final state of the game.
    return sum(reduce(lambda x, y: x * (y % 2), next_state))


if __name__ == "__main__":
    with open(sys.argv[1], "r") as f:
        input_sequence = parse(f.read())

    print(part_one(input_sequence))
    print(part_two(input_sequence))
################################################################

Solution:
['.', '.', '.', '.', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', '.', '.']

