Input token: 326
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['f', 'f', 'f', 'f', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', 'i', '.', 'f', 'f', 'f', 'f', '.', '.', '.', '.', '.']

Example_2:
input: ['.', '.', 'e', 'e', 'e', 'e', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', 'i', '.', 'e', 'e', 'e', 'e', '.', '.', '.']

Example_3:
input: ['.', 'f', 'f', 'f', 'f', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', 'i', '.', 'f', 'f', 'f', 'f', '.', '.', '.', '.']

Test case:
input: ['.', '.', 'g', 'g', 'g', 'g', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', '.', '.', '.', 'i', '.', 'g', 'g', 'g', 'g', '.', '.', '.', '.']
"""

import sys
from collections import deque, defaultdict
from functools import reduce
from itertools import islice
from operator import itemgetter
from random import shuffle

class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        
        if not s or len(s) == 0: return []
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复杂度为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终返回所有的单词。
        words = list(s)
        for word in words:
            self._reverseWord(word)
            
        return words
    
    def _reverseWord(self, word):
        """
        :type word: str
        :param word: 需要反转的单词
        :return: None
        """
        if not word: return
        
        # 使用双指针实现，时间复杂度为 O(n)，空间复权为 O(1)。
        start = 0
        end = len(word)-1
        while True:
            if word[start]!= word[end]: break
            swap = word[start], word[end]
            word[start], word[end] = word[end], word[swap]
            start += 1
            end -= 1
            
        # 如果两边都是大写字母，则不会出现交换操作，直接返回。
        if word[start] >= ord('a') and word[end] <= ord('z'):
            return
        
        self._reverseWord(word[:])
        self._reverseWord(word[-1::-1])
        
    def reverseWordsExceptLast(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        
        if not s or len(s) == 0: return []
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复杂度为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终返回所有的单词。
        words = list(s)
        for word in words:
            self._reverseWord(word)
            
        return words
    
    def _reverseWord(self, word):
        """
        :type word: str
        :param word: 需要反转的单词
        :return: None
        """
        if not word: return
        
        # 使用双指针实现，时间复杂度为 O(n)，空间复权为 O(1)。
        start = 0
        end = len(word)-1
        while True:
            if word[start]!= word[end]: break
            swap = word[start], word[end]
            word[start], word[end] = word[end], word[swap]
            start += 1
            end -= 1
            
        # 如果两边都是大写字母，则不会出现交换操作，直接返回。
        if word[start] >= ord('a') and word[end] <= ord('z'):
            return
        
        self._reverseWord(word[:])
        self._reverseWord(word[-1::-1])
        
    def reverseWordsWithoutRepeated(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        
        if not s or len(s) == 0: return
################################################################

Solution:
['.', '.', '.', '.', '.', '.', '.', 'i', '.', 'g', 'g', 'g', 'g', '.', '.', '.']

