Input token: 582
Output token: 449
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'g', 'g', 'g', 'g', '.', 'g', 'g', 'g', '.', 'g', 'g', 'g', '.', '.', 'g', 'g', 'g', '.', 'g', 'g', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'h', 'h', 'h', 'h', '.', 'e', 'e', 'e', '.', 'e', 'e', 'e', '.', '.', 'e', 'e', 'e', '.', 'h', 'h', '.', '.', '.', '.', '.', '.', '.', '.']

Example_2:
input: ['.', '.', '.', 'g', 'g', 'g', 'g', '.', 'g', 'g', 'g', 'g', 'g', '.', '.', 'g', 'g', 'g', 'g', '.', 'g', 'g', 'g', '.', 'g', 'g', '.', '.', '.']
output: ['.', '.', '.', 'h', 'h', 'h', 'h', '.', 'e', 'e', 'e', 'e', 'e', '.', '.', 'h', 'h', 'h', 'h', '.', 'e', 'e', 'e', '.', 'h', 'h', '.', '.', '.']

Example_3:
input: ['.', '.', '.', 'g', 'g', 'g', 'g', 'g', 'g', '.', '.', '.', 'g', 'g', 'g', '.', '.', '.', 'g', 'g', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', 'h', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', 'e', 'e', 'e', '.', '.', '.', 'e', 'e', 'e', 'e', 'e', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', 'g', 'g', 'g', 'g', '.', 'g', 'g', 'g', '.', '.', '.', 'g', 'g', 'g', 'g', '.', 'g', '.', 'g', 'g', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', 'h', 'h', 'h', 'h', '.', 'e', 'e', 'e', '.', '.', '.', 'e', 'e', 'e', 'e', '.', 'h', '.', 'e', 'e', '.', '.', '.', '.', '.', '.', '.']
"""

import collections


class Solution(object):
    def transform(self, grid):
        """
        :type grid: List[str]
        :rtype: List[str]
        """
        
        # 0. check inputs & outputs
        assert isinstance(grid, list) and len(grid) > 0,\
            "Input grid should be a non-empty list."
        for i in range(len(grid)):
            if not isinstance(grid[i], str) or len(grid[i])!= 1:
                raise ValueError("Each element of grid should be a string with length == 1.")
            
        # 1. process
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        queue = collections.deque()
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j] == ".":
                    continue
                else:
                    queue.append((i, j))
        while queue:
            x, y = queue.popleft()
            for dx, dy in directions:
                newx = x + dx
                newy = y + dy
                if 0 <= newx < len(grid) and 0 <= newy < len(grid[newx]) \
                   and grid[newx][newy] == ".":
                    grid[newx][newy] = grid[x][y]
                    queue.append((newx, newy))
        return grid

################################################################

Solution:
['.', '.', 'h', 'h', 'h', 'h', '.', 'e', 'e', 'e', '.', '.', '.', 'h', 'h', 'h', 'h', '.', 'e', '.', 'h', 'h', '.', '.', '.', '.', '.', '.', '.']

