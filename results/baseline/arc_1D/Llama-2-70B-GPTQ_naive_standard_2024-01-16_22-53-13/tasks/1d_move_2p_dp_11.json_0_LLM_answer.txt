Input token: 478
Output token: 588
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', '.', 'h', 'h', 'h', 'h', '.', '.', 'a', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', 'h', 'h', 'h', 'h', 'a', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_2:
input: ['.', '.', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '.', '.', 'a', '.', '.']
output: ['.', '.', '.', '.', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', '.', '.']

Example_3:
input: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'g', 'g', 'g', '.', '.', 'a', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'g', 'g', 'g', 'a', '.', '.', '.', '.', '.', '.']

Test case:
input: ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', '.', '.', 'a', '.']
################################################################

LLM answer:

output: ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'a', '.']
"""

import re
from typing import List, Optional


class Solution:
    def findReplaceString(self, s: str) -> str:
        """
        思路：正则表达式匹配，替换字符串。
            - 先判断是否有'a'，如果没有就返回原字符串；
            - 然后用正则表达式寻找所有的'a'前面的字符串，并且将其转化为小写字母；
            - 最后再用正则表达式寻找所有的'a'后面的字符串，并且将其转化为大写字母。
            注意：这里使用了两个正则表达式，一个是含有'a'的字符串，另外一个是不包含'a'的字符串。
                  因此，我们需要在第二次正则表达式中加入'a'来避免重复匹配到上一次已经处理过的字符串。
        :param s:
        :return:
        """
        if not re.search('a', s): return s
        # 首先获取所有的'a'前面的字符串
        pre = re.findall("[^a]*(?=a)", s)
        for i in range(len(pre)):
            # 将每个字符串转化为小写字母
            pre[i] = pre[i].lower()
        # 然后获取所有的'a'后面的字符串
        post = re.findall("(?<=a)[^a]*", s)
        for j in range(len(post)):
            # 将每个字符串转化为大写字母
            post[j] = post[j].upper()
        # 组合起来得到最终结果
        result = "".join([x + y for x, y in zip(pre, post)])
        return result

################################################################

Solution:
['.', '.', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'a', '.']

