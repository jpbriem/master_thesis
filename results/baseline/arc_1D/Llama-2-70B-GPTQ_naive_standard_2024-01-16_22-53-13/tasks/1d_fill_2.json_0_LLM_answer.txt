Input token: 352
Output token: 717
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', 'e', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'e', '.', '.']
output: ['.', '.', '.', '.', '.', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', '.', '.']

Example_2:
input: ['.', '.', '.', 'e', '.', '.', '.', '.', '.', '.', '.', '.', 'e', '.', '.', '.', '.', '.']
output: ['.', '.', '.', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', '.', '.', '.', '.', '.']

Example_3:
input: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'f', '.', 'f', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'f', 'f', 'f', '.', '.']

Test case:
input: ['.', '.', '.', '.', '.', '.', '.', '.', 'c', '.', '.', 'c', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '.', '.', '.']
"""

from typing import List, Optional

class Solution:
    def islandPerimeter(self, grid: List[List[str]]) -> int:
        """
        1. 先找到所有的岛，然后计算每个岛的周长。
        2. 最终结果是所有岛的周长之和。
        3. 注意：不要考虑边界情况（例如，海洋没有任何邻居）。
            "." 表示水或者其他格子，而字母则表示一座岛屿中的一个位置。
            每个岛都是由相连的土地构成的，并且你可以循环移动这些土地。
            特别地，两个土地间只能在上下左右方向上相邻。
            因此，这些土地形成了一个面积为正整数的矩形。
            同时，土地只包含大写英文字母（'A' ~ 'Z')。
            给定一个二维字符矩阵代表这些岛屿，请返回这些岛屿的周长。
        """
        if not grid or not grid[0]: return 0
        m = len(grid)
        n = len(grid[0])
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '.' or grid[i][j] == 'o': continue
                # 记录当前岛的四条边的长度
                x, y = i, j
                while True:
                    if grid[x - 1][y]!= '.':
                        res += 1
                        break
                    else:
                        x -= 1
                while True:
                    if grid[x + 1][y]!= '.':
                        res += 1
                        break
                    else:
                        x += 1
                while True:
                    if grid[x][y - 1]!= '.':
                        res += 1
                        break
                    else:
                        y -= 1
                while True:
                    if grid[x][y + 1]!= '.':
                        res += 1
                        break
                    else:
                        y += 1
        return res

if __name__ == "__main__":
    solution = Solution()
    print(solution.islandPerimeter([['a'], ['b'], ['c'], ['d']]))

################################################################

Solution:
['.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 'c', 'c', '.', '.', '.', '.', '.', '.']

