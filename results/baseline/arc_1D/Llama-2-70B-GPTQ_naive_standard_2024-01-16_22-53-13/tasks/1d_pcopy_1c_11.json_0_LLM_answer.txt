Input token: 565
Output token: 399
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'a', 'a', 'a', '.', '.', '.', 'a', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'a', 'a', 'a', '.', '.', 'a', 'a', 'a', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_2:
input: ['.', 'f', 'f', 'f', '.', '.', 'f', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'f', 'f', 'f', '.', 'f', 'f', 'f', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', '.', 'd', 'd', 'd', '.', '.', '.', 'd', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', 'd', 'd', 'd', '.', '.', 'd', 'd', 'd', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', 'c', 'c', 'c', '.', '.', 'c', '.', '.', '.', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', 'c', 'c', 'c', '.', '.', 'c', 'c', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
'''

import collections

class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[str]
        :rtype: int
        """
        
        if not grid or len(grid) == 0: return 0
        
        m = len(grid)
        n = len(grid[0])
        
        directions = [(i, j + 1), (i - 1, j), (i, j - 1)]
        perimeters = []
        for i in range(m):
            for j in range(n):
                if grid[i][j]!= '.':
                    perimeters.append([i, j, 0])
        
        while perimeters:
            p = perimeters.pop()
            
            x, y, cnt = p
            for d in directions:
                dx, dy = d
                if 0 <= dx < m and 0 <= dy < n and grid[dx][dy] == '.':
                    perimeters.append((x+dx, y+dy, cnt))
                    
                    grid[x+dx][y+dy] = '#'
                    grid[p[0]][p[1]] = '#'
                    break
        
        return sum(map(lambda x: x[-1], perimeters))

################################################################

Solution:
['.', '.', 'c', 'c', 'c', '.', 'c', 'c', 'c', '.', 'c', 'c', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

