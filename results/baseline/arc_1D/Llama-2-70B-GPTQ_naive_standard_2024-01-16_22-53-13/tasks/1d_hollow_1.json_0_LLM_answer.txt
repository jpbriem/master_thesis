Input token: 461
Output token: 661
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'b', '.', '.', '.', '.', '.', '.', 'b', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_2:
input: ['.', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'a', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'a', '.', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', '.', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', '.', '.']
output: ['.', '.', 'a', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'a', '.', '.']

Test case:
input: ['.', '.', '.', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
"""

import re
from typing import List, Optional


class Solution:
    def removeIslandObstacles(self, grid: List[List[str]]) -> None:
        """
        找到所有的岛，然后去除它们周围的障碍物。

        :param grid: 二维列表，每一个元素都是字符串类型
        :return: 无返回值
        """
        if not grid or not isinstance(grid[0], list):
            return

        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j] == ".":
                    continue
                else:
                    self._remove_islands(grid, i, j)

    @staticmethod
    def _remove_islands(grid: List[List[str]], x: int, y: int) -> None:
        """
        移除指定位置的岛及其周边的障碍物

        :param grid: 二维列表，每一个元素都是字符串类型
        :param x: 行索引
        :param y: 列索引
        :return: 无返回值
        """
        # 获取当前点的四个方向上的相邻点
        directions = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
        # 记录已经走过的点
        visited = set()
        queue = []
        queue.append((x, y))
        while len(queue) > 0:
            current_point = queue.pop(0)
            if current_point in visited:
                continue
            visited.add(current_point)
            if grid[current_point[0]][current_point[1]]!= "." \
                    and grid[current_point[0]][current_point[1]]!= "#":
                grid[current_point[0]][current_point[1]] = "."
            for direction in directions:
                if direction in visited:
                    continue
                elif direction in ((x, y), (-1, -1), (1, 1), (-1, 1), (1, -1)):
                    continue
                elif grid[direction[0]][direction[1]] == "#":
                    queue.append(direction)

################################################################

Solution:
['.', '.', '.', 'c', '.', '.', '.', '.', '.', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

