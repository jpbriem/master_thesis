Input token: 1056
Output token: 1026
################################################################

LLM prompt:
train input:
[[0, 0, 0, 0, 2, 2, 0, 0, 1], [0, 1, 1, 0, 2, 2, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 2], [1, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1]]
train output:
[[1, 1, 0, 0, 0]]

train input:
[[1, 1, 0, 2, 0, 0, 0, 0, 2], [1, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 2, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 2, 2, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 1, 1, 0], [0, 1, 0, 2, 2, 0, 1, 1, 0]]
train output:
[[1, 1, 1, 1, 0]]

train input:
[[2, 2, 0, 1, 1, 0, 0, 0, 0], [2, 2, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 2, 2], [0, 1, 1, 0, 0, 1, 0, 2, 2]]
train output:
[[1, 1, 1, 1, 0]]

test input:
[[0, 0, 0, 0, 0, 2, 2, 0, 1], [1, 1, 0, 1, 0, 2, 2, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 2, 2, 0, 0, 1, 1, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 2, 2, 0], [2, 2, 0, 1, 1, 0, 2, 2, 0], [2, 2, 0, 1, 1, 0, 0, 0, 0]]
################################################################

LLM answer:

test output:
[[1, 1, 1, 1, 0]]
```

## Answer (3)

# Python 3.8 (pre-release), ~~45~~ 44 bytes

```
lambda x:[sum(x[:i])>sum(x[i+1:])for i in range(len(x)-1)]
```

Try it online!

Comment: `range(len(x))` -> `range(len(x)-1)`.

Comment: @KevinCruijssen Thanks! I'm not sure why I didn't think of that...

## Answer (3)

# Jelly, 6 bytes

```
Ḷ⁼€ṚẎƊ
```

A monadic Link accepting a list which yields the truthy/falsy values for each index where the sum of elements to the left is greater than or equal to the sum of elements to the right.

**Try it online!** Or see the test-suite.

### How?

```
Ḷ⁼€ṚẎƊ - Link: list, L                   e.g. [1,2,3]
Ḷ       - length                          3
    €   - for each element X of L:        [1,2,3]
    Ṛ   - reverse                         [3,2,1]
     Ẏ  - last two links as a dyad          [1,2,3]
    ⁼€  - equals?                         [[True,False,False],[False,True,False],[False,False,True]]
      Ɗ - main link: reduce by:            [[True,False,False],[False,True,False],[False,False,True]]
```

## Answer (3)

# Haskell, 79 bytes

```
import Data.List
f l=map(\a->takeWhile((>=).sum)(scanl(+)0$drop a l))[0..length l-1]
```

Try it online!

## Answer (3)

# JavaScript (ES6), 53 bytes

```
s=>s.map((_,i)=>(s.slice(0,i)>s.slice(i+1)?1:0))
```

Try it online!

## Answer (2)

# R, ~~49~~ 48 bytes

```
function(x)cumsum(x)[-nchar(x)+1:nchar(x)]<0
```

Try it online!

## Answer (2)

# CJam, 14 bytes

```
q~{_z{_<}%}*
```

Try it online!

## Explanation

```
q~               " Read and evaluate the input string.
 {              }* " For each character in the resulting array:
  _z             " Push its code point.
     {          }% " If this is less than the previous one:
      _<         "   Push 1; otherwise push 0.
```

## Answer (2)

# Perl 5, 34 + 1 (-p) = 35 bytes

```
$_=$_;s/(.)/$&lt $&>/ge;say y/^0//
```

Try it online!

## Answer (2)

# Pyth, 10 bytes

```
hQVGdTQeQ
```

Test suite.

## Answer (2)

# Ruby, 41 bytes

```
->a{(a<<0).each_cons(2){|b,c|puts b<=>c}}
```

Try it online!

## Answer (2)

# Retina 0.8.2, 24 bytes

```
\d
$*
+`(.)(.*)$
$1<$2
```

Try it online! Link includes test cases. Explanation:

```
\d
$*
```

Convert the digits to their ASCII codes.

```
+`(.)(.*)$
$1<$2
```

Compare each digit with the
################################################################

Solution:
[[1, 1, 1, 0, 0]]

