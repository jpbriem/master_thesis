Input token: 268
Output token: 754
################################################################

LLM prompt:
train input:
[[0, 0, 0, 0], [0, 3, 4, 0], [0, 7, 6, 0], [0, 0, 0, 0]]
train output:
[[3, 0, 0, 4], [0, 0, 0, 0], [0, 0, 0, 0], [7, 0, 0, 6]]

train input:
[[0, 0, 0, 0], [0, 5, 6, 0], [0, 8, 3, 0], [0, 0, 0, 0]]
train output:
[[5, 0, 0, 6], [0, 0, 0, 0], [0, 0, 0, 0], [8, 0, 0, 3]]

test input:
[[0, 0, 0, 0], [0, 2, 3, 0], [0, 4, 9, 0], [0, 0, 0, 0]]
################################################################

LLM answer:

test output:
[[2, 0, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [4, 0, 0, 9]]
'''

import numpy as np
from sklearn.metrics import accuracy_score

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

class NeuralNetwork():
    def __init__(self, n_inputs, n_hidden, n_outputs):
        self.n_inputs = n_inputs
        self.n_hidden = n_hidden
        self.n_outputs = n_outputs

        # initialize weights and biases
        self.weights_ih = np.random.randn(self.n_hidden, self.n_inputs) * 0.01
        self.biases_h = np.zeros((self.n_hidden, 1))
        self.weights_ho = np.random.randn(self.n_outputs, self.n_hidden) * 0.01
        self.biases_o = np.zeros((self.n_outputs, 1))

    def forward(self, inputs):
        # feedforward propagation
        hidden_layer_input = np.dot(self.weights_ih, inputs) + self.biases_h
        hidden_layer_output = sigmoid(hidden_layer_input)
        output_layer_input = np.dot(self.weights_ho, hidden_layer_output) + self.biases_o
        output_layer_output = sigmoid(output_layer_input)
        return output_layer_output

    def backward(self, outputs, targets):
        # backpropagation of errors
        delta_o = outputs - targets
        delta_h = np.dot(self.weights_ho.T, delta_o) * sigmoid(hidden_layer_input, 1) * (1 - sigmoid(hidden_layer_input, 1))
        delta_i = np.dot(self.weights_ih.T, delta_h) * sigmoid(inputs, 1) * (1 - sigmoid(inputs, 1))

        # update weights and biases using gradient descent
        self.weights_ho += np.dot(delta_o, hidden_layer_output.T)
        self.biases_o += np.sum(delta_o, axis=0, keepdims=True)
        self.weights_ih += np.dot(delta_h, inputs.T)
        self.biases_h += np.sum(delta_h, axis=0, keepdims=True)

    def train(self, X, y, epochs=1000, learning_rate=0.01):
        for _ in range(epochs):
            for i in range(len(X)):
                outputs = self.forward(X[i])
                self.backward(outputs, y[i])

    def predict(self, X):
        predictions = []
        for x in X:
            prediction = self.forward(x)
            predictions.append(prediction)
        return predictions
################################################################

Solution:
[[2, 0, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [4, 0, 0, 9]]

