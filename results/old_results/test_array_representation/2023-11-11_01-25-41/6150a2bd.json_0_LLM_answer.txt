Input token: 163
Output token: 878
################################################################

LLM prompt:
train input:
[[3, 3, 8], [3, 7, 0], [5, 0, 0]]
train output:
[[0, 0, 5], [0, 7, 3], [8, 3, 3]]

train input:
[[5, 5, 2], [1, 0, 0], [0, 0, 0]]
train output:
[[0, 0, 0], [0, 0, 1], [2, 5, 5]]

test input:
[[6, 3, 5], [6, 8, 0], [4, 0, 0]]
################################################################

LLM answer:

test output:
[[0, 0, 4], [0, 8, 6], [5, 3, 6]]
'''

def get_input():
    with open('data.txt', 'r') as f:
        lines = f.readlines()
        return [[int(x) for x in line.split()] for line in lines]

def get_output(input):
    output = []
    for i in range(len(input)):
        row = []
        for j in range(len(input[i])):
            if input[i][j] == 9:
                row.append(0)
            else:
                row.append(input[i][j])
        output.append(row)
    return output

def get_neighbours(matrix, i, j):
    neighbours = []
    for k in range(-1, 2):
        for l in range(-1, 2):
            if (k!= 0 or l!= 0):
                try:
                    neighbours.append([i + k, j + l])
                except IndexError:
                    pass
    return neighbours

def get_adjacent_values(matrix, i, j):
    adjacent_values = []
    for neighbour in get_neighbours(matrix, i, j):
        try:
            adjacent_values.append(matrix[neighbour[0]][neighbour[1]])
        except IndexError:
            pass
    return adjacent_values

def get_lowest_value(matrix, i, j):
    lowest_value = matrix[i][j]
    for value in get_adjacent_values(matrix, i, j):
        if value < lowest_value and value!= 9:
            lowest_value = value
    return lowest_value

def get_basin_size(matrix, i, j):
    basin_size = 0
    queue = deque([(i, j)])
    while len(queue) > 0:
        current_position = queue.popleft()
        if matrix[current_position[0]][current_position[1]] == 9:
            continue
        elif matrix[current_position[0]][current_position[1]] == 0:
            basin_size += 1
        else:
            for neighbour in get_neighbours(matrix, current_position[0], current_position[1]):
                if neighbour not in queue:
                    queue.append(neighbour)
    return basin_size

def part_one(input):
    output = get_output(input)
    risk_levels = []
    for i in range(len(output)):
        for j in range(len(output[i])):
            if output[i][j] == 9:
                risk_levels.append(get_lowest_value(output, i, j))
    print(min(risk_levels))

def part_two(input):
    output = get_output(input)
    basins = []
    for i in range(len(output)):
        for j in range(len(output[i])):
            if output[i][j] == 9:
                basins.append(get_basin_size(output, i, j))
    sorted_basins = sorted(basins)[::-1]
    product = 1
    for i in range(3):
        product *= sorted_basins[i]
    print(product)

if __name__ == "__main__":
    input = get_input()
    #part_one(input)
    part_two(input)
################################################################

Solution:
[[0, 0, 4], [0, 8, 6], [5, 3, 6]]

