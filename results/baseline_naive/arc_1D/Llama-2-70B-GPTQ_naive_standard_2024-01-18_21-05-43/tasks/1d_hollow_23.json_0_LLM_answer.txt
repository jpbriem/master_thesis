Input token: 313
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['a', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'a', 'a', 'a', 'a']
output: ['a', 'i', 'a', 'a', 'a', 'a', 'a', 'i', 'a', 'a', 'a', 'a']

Example_2:
input: ['a', 'c', 'c', 'c', 'c', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
output: ['a', 'c', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'a', 'a', 'a']

Example_3:
input: ['a', 'a', 'a', 'e', 'e', 'e', 'a', 'a', 'a', 'a', 'a', 'a']
output: ['a', 'a', 'a', 'e', 'a', 'e', 'a', 'a', 'a', 'a', 'a', 'a']

Test case:
input: ['a', 'a', 'a', 'a', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'a']
################################################################

LLM answer:

expected output: ['a', 'a', 'a', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'a', 'a']
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

def get_next_node(root, node, direction='right'):
    if root is None or node is None: return None
    if direction == 'left':
        while True:
            if node.val!= root.val: break
            node = node.children[0]
    elif direction == 'right':
        while True:
            if node.val!= root.val: break
            node = node.children[-1]
    else: raise ValueError('direction must be "left", "right"')
    return node

def get_parent_node(root, node):
    parent = None
    while True:
        if node.val!= root.val: break
        parent = node
        node = node.children[0]
    return parent

def get_sibling_nodes(root, node, direction='right'):
    siblings = []
    if root is None or node is None: return siblings
    if direction == 'left':
        while True:
            if node.val!= root.val: break
            siblings.append(node)
            node = node.children[0]
    elif direction == 'right':
        while True:
            if node.val!= root.val: break
            siblings.append(node)
            node = node.children[-1]
    else: raise ValueError('direction must be "left", "right"')
    return siblings

def get_child_nodes(root, node, direction='right'):
    child_nodes = []
    if root is None or node is None: return child_nodes
    if direction == 'left':
        while True:
            if node.val!= root.val: break
            child_nodes.extend([n for n in node.children])
            node = node.children[0]
    elif direction == 'right':
        while True:
            if node.val!= root.val: break
            child_nodes.extend([n for n in reversed(list(node.children))])
            node = node.children[-1]
    else: raise ValueError('direction must be "left", "right"')
    return child_nodes

def find_first_different_node(root, node, direction='right'):
    if root is None or node is None: return None
    if direction == 'left':
        while True:
            if node.val!= root.val: break
            node = node.children[0]
    elif direction == 'right':
        while True:
            if node.val!= root.val: break
            node = node.children[-1]
    else: raise ValueError('direction must be "left", "right"')
    return node

def find_last_different_node(root, node, direction='right'):
    if root is None or node is None: return None
    if direction == 'left':
        while True:
            if node.val!= root.val: break
            node = node.children[0]
    elif direction == 'right':
        while True:
            if node.val!= root.val: break
            node = node.children[-1]
    else: raise ValueError('direction must be "left", "right"')
    return node

def find_common_ancestor(root, nodes):
    if len(nodes) < 2: return None
    common_ancestors = set()
    for node in nodes:
        ancestor = get_parent_node(root, node)
        if ancestor is not None:
            common_ancestors.add(ancestor)
    return list(common_ancestors)[0]

def find_common_descendant(root, nodes):
    if len(nodes) < 2: return None
    common_descendants = set()
    for node in nodes:
        descendant = find_first_different_node(root, node)
        if descendant is not None:
            common_descendants.add(descendant)
    return list(common_descendants)[
################################################################

Solution:
['a', 'a', 'a', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'c', 'a']

