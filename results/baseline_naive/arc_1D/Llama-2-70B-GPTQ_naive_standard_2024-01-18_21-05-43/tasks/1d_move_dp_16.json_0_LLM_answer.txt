Input token: 523
Output token: 483
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'c', 'c', 'c', 'a', 'a', 'a', 'a', 'j', 'a', 'a', 'a']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'c', 'c', 'c', 'j', 'a', 'a', 'a']

Example_2:
input: ['a', 'a', 'a', 'a', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'a', 'a', 'a', 'a', 'j', 'a']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'j', 'a']

Example_3:
input: ['a', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'a', 'a', 'a', 'a', 'a', 'j']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'j']

Test case:
input: ['a', 'a', 'a', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a', 'j']
################################################################

LLM answer:

output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'j']
"""
from typing import List, Optional


class Solution:
    def transform(self, arr: List[str]) -> str:
        """
        思路：找到最后一个不是'a'的字符，然后将其前面所有元素都变成这个字符。
            - 如果最后一个不是'a'的字符为空，则返回原数组
            - 否则，从最后一个不是'a'的字符开始向左遍历，直至遇到第一个不是'a'的字符或者遇到数组头部
                - 如果遇到了第一个不是'a'的字符，则将该位置之前的所有元素全部改为该字符
                    并且将该字符设置为新的最后一个不是'a'的字符
                - 否则，将该字符设置为新的最后一个不是'a'的字符
        :param arr:
        :return:
        """
        if not arr or all('a' == x for x in arr):
            return arr

        last = len(arr) - 1
        while arr[last] == 'a':
            last -= 1
        new_last = last
        while True:
            left = last - 1
            while arr[left] == 'a':
                left -= 1
            if left < 0:
                break
            arr[:new_last + 1] = [arr[left]] * (new_last - last + 1)
            new_last = left
        return arr

################################################################

Solution:
['a', 'a', 'a', 'a', 'a', 'a', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'j']

