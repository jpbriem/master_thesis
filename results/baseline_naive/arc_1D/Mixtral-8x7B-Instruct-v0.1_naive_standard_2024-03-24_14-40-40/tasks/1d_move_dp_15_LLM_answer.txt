
###########################################################
New Step
###########################################################
prompt_log: Sample Prompt:
Example_1:
input: ['b', 'b', 'b', 'b', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'h']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'h']

Example_2:
input: ['i', 'i', 'i', 'i', 'i', 'a', 'a', 'a', 'h', 'a', 'a', 'a']
output: ['a', 'a', 'a', 'i', 'i', 'i', 'i', 'i', 'h', 'a', 'a', 'a']

Example_3:
input: ['a', 'a', 'a', 'f', 'f', 'f', 'f', 'a', 'a', 'a', 'h', 'a']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'f', 'f', 'f', 'f', 'h', 'a']

Test case:
input: ['e', 'e', 'e', 'e', 'e', 'a', 'a', 'a', 'a', 'a', 'h', 'a']

###########################################################
Sample Outputs:
output: ['a', 'a', 'a', 'a', 'a', 'a', 'e', 'e', 'e', 'e', 'h', 'a']
*/

// Solution 1:
function sortByHeight(arr) {
    let sorted = [];
    let trees = arr.filter((el, i) => el!== "h").map((el, i) => [el, i]);
    trees.sort((a, b) => a[0] - b[0]);
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === "h") {
            sorted.push("h");
        } else {
            sorted.splice(trees[i][1], 0, trees[i][0]);
        }
    }
    return sorted;
}

// Solution 2:
const sortByHeight = arr => [...arr].reduce((p, c, i) => {
    if (c === 'h') p.push('h');
    else p.splice(p.findIndex(x => x === 'h' || Number(x) > Number(c)), 0, c);
    return p;
}, [])


###########################################################
Result:
solution: ['a', 'a', 'a', 'a', 'a', 'e', 'e', 'e', 'e', 'e', 'h', 'a']

success: 0

too_long_prompt: False

tries: 1

success_rate: 0.28937007874015747

cat_success_cnt: 0

cat_success_rate: 0.0

