
###########################################################
New Step
###########################################################
prompt_log: Sample Prompt:
Example_1:
input: ['a', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'a', 'a', 'a', 'e']
output: ['a', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'e']

Example_2:
input: ['a', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'a', 'a', 'e', 'a', 'a']
output: ['a', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'e', 'a', 'a']

Example_3:
input: ['a', 'a', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'a', 'a', 'a', 'e']
output: ['a', 'a', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'e']

Test case:
input: ['a', 'a', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'a', 'a', 'a', 'a', 'a', 'e', 'a']

###########################################################
Sample Outputs:
output: ['a', 'a', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'a', 'a', 'a', 'a', 'a', 'e', 'a']
*/

// Solution 1:
const removeDuplicateLetters = (s) => {
  const stack = [];
  const countMap = {};
  for (let i = 0; i < s.length; i++) {
    countMap[s[i]] = (countMap[s[i]] || 0) + 1;
  }
  for (let char of s) {
    if (!stack.includes(char)) {
      while (
        stack.length &&
        stack[stack.length - 1] > char &&
        countMap[stack[stack.length - 1]]--
      ) {
        stack.pop();
      }
      stack.push(char);
    } else {
      countMap[char]--;
    }
  }
  return stack.join("");
};

// Solution 2:
/*
  We can use a hashmap to keep track of the last index of each character in the string, and then iterate through the string again from left to right. For each character, we check whether there exists an earlier character that is larger than it but has not been included yet. If such a character exists, we update its position in the hashmap to be the current position of the character being processed. After processing all characters, we construct the final result by including only those characters whose positions are equal to their first occurrences.

  Time Complexity: O(n), where n is the length of the input string.
  Space Complexity: O(1), assuming the size of the alphabet is constant.
*/
const removeDuplicateLetters = (s) => {
  let lastIndex = new Array(26).fill(-1); // Initialize with -1 as default value
  for (let i = 0; i < s.length; i++) {
    lastIndex[s[i].charCodeAt() - "a".charCodeAt()] = i;
  }
  let res = "";
  for (let i = 0; i < s.length; i++) {
    const c = s[i];
    if (lastIndex[c.charCodeAt() - "a".charCodeAt()] === i) {
      res += c;
    }
    for (let j = c.charCodeAt() - "a".charCodeAt() - 1; j >= 0; j--) {
      if (lastIndex[j]!== -1 && lastIndex[j] < i) {
        res += String.fromCharCode(j + "a".charCodeAt());
        break;
      }
    }
  }
  return res;
};


###########################################################
Result:
solution: ['a', 'a', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'e', 'a']

success: 0

too_long_prompt: False

tries: 1

success_rate: 0.24504084014002334

cat_success_cnt: 2

cat_success_rate: 0.2857142857142857

