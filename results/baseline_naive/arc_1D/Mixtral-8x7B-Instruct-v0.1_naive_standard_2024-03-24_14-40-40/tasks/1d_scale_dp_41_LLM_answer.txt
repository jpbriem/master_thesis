
###########################################################
New Step
###########################################################
prompt_log: Sample Prompt:
Example_1:
input: ['a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'a', 'e', 'a']
output: ['a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'e', 'a']

Example_2:
input: ['a', 'a', 'c', 'c', 'c', 'a', 'a', 'a', 'a', 'a', 'a', 'e', 'a', 'a']
output: ['a', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'e', 'a', 'a']

Example_3:
input: ['a', 'a', 'a', 'a', 'h', 'h', 'h', 'h', 'h', 'h', 'a', 'a', 'e', 'a']
output: ['a', 'a', 'a', 'a', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'e', 'a']

Test case:
input: ['c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'a', 'a', 'e', 'a', 'a']

###########################################################
Sample Outputs:
output: ['c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'e', 'a', 'a']
*/

// Solution 1:
class Solution {
    public String[] rearrangeString(String[] strs) {
        int len = strs.length;
        if (len == 0 || len == 1) return strs;

        // count the number of each char in input array
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < len; i++) {
            char c = strs[i].charAt(0);
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());
        pq.addAll(map.entrySet());

        List<String> list = new ArrayList<>();
        while (!pq.isEmpty()) {
            Map.Entry<Character, Integer> entry = pq.poll();
            char key = entry.getKey();
            int value = entry.getValue();

            // add chars to output array until we meet one with more than half frequency
            for (int j = 0; j < Math.min(value, len / 2); j++) {
                list.add("" + key);
                len--;
            }

            // put back into priority queue if there are still left
            if (value > len / 2) {
                pq.add(new AbstractMap.SimpleEntry<>(key, value));
            }
        }

        // fill rest of the array with remaining characters
        for (String s : strs) {
            if (!list.contains(s)) {
                list.add(s);
            }
        }

        return list.toArray(new String[0]);
    }
}

// Solution 2:
class Solution {
    public String[] rearrangeString(String[] strs) {
        int len = strs.length;
        if (len == 0 || len == 1) return strs;

        // count the number of each char in input array
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < len; i++) {
            char c = strs[i].charAt(0);
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        // sort by freq and then alphabetical order
        List<Map.Entry<Character, Integer>> list = new ArrayList<>(map.entrySet());
        Collections.sort(list, (a, b) -> a.getValue().compareTo(b.getValue()));
        Collections.sort(list, (a, b) -> a.getKey().compareTo(b.getKey()));

        StringBuilder sb = new StringBuilder();
        boolean flag = false;
        while (!list.isEmpty()) {
            Map.Entry<Character, Integer> entry = list.remove(list.size() - 1);
            char key = entry.getKey();
            int value = entry.getValue();

            // add chars to output string builder until we meet one with more than half frequency
            for (int j = 0; j < Math.min(value, len / 2); j++) {
                sb.append(key);
                len--;
            }

            // put back into list if there are still left
            if (value > len / 2) {
                list.add(new AbstractMap.SimpleEntry<>(key, value));
            } else {
                flag = true;
            }
        }

        // check whether all elements have been added or not
        if (flag && len!= 0) {
            throw new IllegalArgumentException("Input is invalid");
        }

        // convert string builder to array
        String[] res = new String[strs.length];
        for (int i = 0; i < res.length; i++) {
            res[i] = "" + sb.charAt(i);
        }

        return res;
    }
}


###########################################################
Result:
solution: ['c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'e', 'a', 'a']

success: 1

too_long_prompt: False

tries: 1

success_rate: 0.25591882750845546

cat_success_cnt: 19

cat_success_rate: 0.5135135135135135

