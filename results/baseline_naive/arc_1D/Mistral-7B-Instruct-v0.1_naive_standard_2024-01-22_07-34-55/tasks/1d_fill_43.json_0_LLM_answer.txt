Input token: 292
Output token: 222
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0]
output: [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0]

Example_2:
input: [0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0]
output: [0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0]

Example_3:
input: [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0]
output: [2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0]

Test case:
input: [5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0]
################################################################

LLM answer:

output: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]

Constraints:
1 <= n <= 10^5
1 <= nums[i] <= 10^9
nums is non-empty
There will be at most 10^4 calls to nums.

class Solution {
public:
    int maxCount(vector<int>& nums) {
        unordered_map<int, int> count;
        for (auto& num : nums) {
            if (count.find(num) == count.end()) {
                count[num] = 1;
            } else {
                count[num]++;
            }
        }
        int ans = 0;
        for (auto& elem : count) {
            ans += elem.second;
        }
        return ans;
    }
};
################################################################

Solution:
[5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0]

