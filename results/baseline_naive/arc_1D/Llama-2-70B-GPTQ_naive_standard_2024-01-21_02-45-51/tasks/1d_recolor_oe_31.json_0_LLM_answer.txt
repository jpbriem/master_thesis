Input token: 544
Output token: 478
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 5, 0, 0, 0]
output: [0, 4, 4, 4, 0, 0, 0, 7, 7, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 4, 0, 0, 0]

Example_2:
input: [0, 0, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 0, 0, 5, 5, 0, 5, 5, 5, 0]
output: [0, 0, 4, 4, 4, 4, 4, 0, 7, 7, 7, 7, 7, 7, 0, 0, 7, 7, 0, 4, 4, 4, 0]

Example_3:
input: [0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0]
output: [0, 4, 4, 4, 0, 7, 7, 7, 7, 7, 7, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0]

Test case:
input: [0, 5, 5, 5, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 0]
################################################################

LLM answer:

output: [0, 4, 4, 4, 4, 0, 0, 7, 7, 7, 0, 0, 0, 7, 7, 7, 0, 4, 4, 4, 4, 4, 0]
"""

import unittest
from typing import List
# from collections import deque


class Solution:
    def transform(self, nums: List[int]) -> List[int]:
        """
        思路：双端队列，左右各自记录最后一个不为0的位置。
                如果当前元素为0，则将两侧非0元素数量相加放入中间；
                否则直接赋值给中间元素。
                O(n)时间复杂度，O(1)空间复杂度。
        """
        left = right = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                nums[i] = max(left + right, 0)
                left += 1; right += 1
            else:
                left -= 1; right -= 1
        return nums


if __name__ == "__main__":
    solution = Solution()
    assert solution.transform([0, 5, 5, 5, 5, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 0]) \
               == [0, 4, 4, 4, 4, 0, 0, 7, 7, 7, 0, 0, 0, 7, 7, 7, 0, 4, 4, 4, 4, 4, 0]

################################################################

Solution:
[0, 7, 7, 7, 7, 0, 0, 4, 4, 4, 0, 0, 0, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0]

