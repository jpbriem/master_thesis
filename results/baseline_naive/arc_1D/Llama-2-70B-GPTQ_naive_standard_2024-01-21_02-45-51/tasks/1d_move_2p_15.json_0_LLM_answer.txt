Input token: 313
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
output: [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]

Example_2:
input: [8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0]
output: [0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0]

Example_3:
input: [0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0]
output: [0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0]

Test case:
input: [4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0]
################################################################

LLM answer:

expected output: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"""

# Definition for a Node.
class Node(object):
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def get_max_depth(root):
    if root is None: return 0
    else: return max(get_max_depth(root.left), get_max_depth(root.right)) + 1

def get_min_depth(root):
    if root is None: return float('inf')
    else: return min(get_min_depth(root.left), get_min_depth(root.right)) + 1

def get_height(root):
    return abs(get_max_depth(root) - get_min_depth(root))

def get_balance_factor(node):
    if node is None: return 0
    else: return (get_height(node.left) - get_height(node.right))

def get_levels(root):
    levels = []
    queue = [(root, 0)]
    while len(queue) > 0:
        current_node, level = queue[0]
        queue.pop(0)
        if current_node is not None:
            levels.append([current_node.val])
            queue += [(current_node.left, level+1), (current_node.right, level+1)]
    return levels

def get_path_to_leaf(root, path=[], depth=-1):
    if root is None or depth == 0: return path
    elif root.left is not None:
        path.extend((root.left.val,))
        return get_path_to_leaf(root.left, path, depth-1)
    elif root.right is not None:
        path.extend((root.right.val,))
        return get_path_to_leaf(root.right, path, depth-1)
    else: return path

def get_paths_from_leaves(root):
    paths = []
    queue = [(root, 0)]
    while len(queue) > 0:
        current_node, level = queue[0]
        queue.pop(0)
        if current_node is not None:
            path = get_path_to_leaf(current_node)
            paths.append(path)
            queue += [(current_node.left, level+1), (current_node.right, level+1)]
    return paths

def get_all_nodes(root):
    nodes = []
    queue = [(root, 0)]
    while len(queue) > 0:
        current_node, level = queue[0]
        queue.pop(0)
        if current_node is not None:
            nodes.append(current_node)
            queue += [(current_node.left, level+1), (current_node.right, level+1)]
    return nodes

def get_all_leaves(root):
    leaves = []
    queue = [(root, 0)]
    while len(queue) > 0:
        current_node, level = queue[0]
        queue.pop(0)
        if current_node is not None:
            if current_node.left is None and current_node.right is None:
                leaves.append(current_node)
            queue += [(current_node.left, level+1), (current_node.right, level+1)]
    return leaves

def get_all_internal_nodes(root):
    internal_nodes = []
    queue = [(root, 0)]
    while len(queue) > 0:
        current_node, level = queue[0]
        queue.pop(0)
        if current_node is not None:
            if current_node.left is not None and current_node.right is not None:
                internal_nodes.append(current_node)
            queue += [(current_node.left, level+1), (current_node.right, level+1)]
    return internal_nodes

def get_all_external_nodes(root):
    external_nodes
################################################################

Solution:
[0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0]

