Input token: 817
Output token: 1018
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]
output: [0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0]

Example_2:
input: [0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0]
output: [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0]

Example_3:
input: [0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0]
output: [0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0]

Test case:
input: [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0]
################################################################

LLM answer:

output: [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"""

import unittest
from typing import List


class Solution:
    def wiggleSort(self, nums: List[int]) -> List[int]:
        """
        思路：找到最大值和最小值，然后对应的数字进行交换。
            - 先排序，再遍历一次，如果当前元素等于最大值或者最小值，则将其与相反位置的元素进行交换。
                - 注意：这里需要考虑边界情况，因为可能会出现最大值在第一个位置、最小值在最后一个位置的情况。
                    所以我们不仅需要判断是否等于最大值/最小值，还需要判断是否等于中间值（即长度除以二）。
        """
        if not nums or len(nums) == 1:
            return nums

        # 获取最大值和最小值
        max_value = min_value = None
        for i in range(len(nums)):
            if max_value is None or nums[i] > max_value:
                max_value = nums[i]
            elif min_value is None or nums[i] < min_value:
                min_value = nums[i]

        # 排序
        nums.sort()

        # 从左右两端开始比较，直到中间
        left_index = right_index = 0
        while True:
            # 如果左右两端都已经超过了中间点，那么就结束了
            if (left_index + 1) * 2 >= len(nums):
                break

            # 如果左边的元素等于最大值，则与右边的元素进行交换
            if nums[left_index] == max_value:
                nums[right_index], nums[left_index] = nums[left_index], nums[right_index]
                right_index += 1

            # 如果右边的元素等于最小值，则与左边的元素进行交换
            if nums[right_index] == min_value:
                nums[left_index], nums[right_index] = nums[right_index], nums[left_index]
                left_index += 1

            # 更新索引
            left_index += 1
            right_index += 1

        return nums


if __name__ == "__main__":
    solution = Solution()
    assert solution.wiggleSort([0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0]) \
               == [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]

################################################################

Solution:
[0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0]

