Input token: 670
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
output: [0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

Example_2:
input: [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0]
output: [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0]

Example_3:
input: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0]
output: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0]

Test case:
input: [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0]
################################################################

LLM answer:

output: [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0]
"""

import unittest
from typing import List
# from collections import deque


class Solution:
    def rotate(self, nums: List[int]) -> None:
        """
        思路：双指针，一个从左往右扫描，一个从右往左扫描。
                    左指针的位置为 i，右指针的位置为 j。
                    当 i == j 时，说明已经完成了转换。
                    如果 i < j，则表示有两种情形：
                            1）i 处数字大于等于 j 处数字，那么交换 i 和 j 处的数字；
                            2）i 处数字小于 j 处数字，那么不用进行任何操作。
                    反之，如果 i > j，则表示有三种情形：
                            1）i 处数字大于等于 j 处数字，那么交换 i 和 j 处的数字；
                            2）i 处数字小于 j 处数字且 i + 1 处数字大于等于 j 处数字，那么交换 i 和 i+1 处的数字；
                            3）i 处数字小于 j 处数字且 i + 1 处数字小于 j 处数字，那么不用进行任何操作。
               注意：这里的 i 和 j 都是从 0 开始计算的下标值。
        Args:
            nums (List[int]): 给定的非空数组。

        Returns:
            None: 无返回值。

        Raises:
            TypeError: 输入参数类型错误。
        """
        if not isinstance(nums, list) or len(nums) <= 1:
            raise TypeError('Input type error')

        left = right = 0
        while True:
            # 第一次循环时，left 和 right 都是 0，所以会进入到 if 语句中去判断
            if nums[right] >= nums[left]:
                nums[right], nums[left] = nums[left], nums[right]
                left += 1
                continue

            # 第二次循环时，left 和 right 都是 1，所以会进入到 elif 语句中去判断
            elif nums[right - 1] >= nums[left]:
                nums[right - 1], nums[left] = nums[left], nums[right - 1]
                right -= 1
                continue

            # 第三次循环时，left 和 right 都是 2，所以会进入到 else 语句中去判断
            else:
                right -= 1
                continue

            break


class TestSolution(unittest.TestCase):
    def test_rotate(self):
        solution = Solution()
        self.assertEqual([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                         solution.rotate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
################################################################

Solution:
[0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0]

