Input token: 271
Output token: 417
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['a', 'c', 'c', 'c', 'c', 'c', 'a', 'a', 'd', 'a']
output: ['a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'd', 'a']

Example_2:
input: ['e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a', 'd']
output: ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'd']

Example_3:
input: ['i', 'i', 'i', 'i', 'a', 'a', 'a', 'a', 'd', 'a']
output: ['i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'a']

Test case:
input: ['g', 'g', 'g', 'g', 'a', 'a', 'a', 'a', 'd', 'a']
################################################################

LLM answer:

output: ['g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'a']
"""

import unittest
from typing import List, Tuple

class Solution:
    def findMaxConsecutiveOnes(self, nums: List[str]) -> int:
        if not nums or len(nums) == 0: return 0
        max_count = 0
        for i in range(len(nums)):
            count = 0
            while True:
                if nums[i]!= "1": break
                count += 1
            max_count = max(max_count, count)
        return max_count

class TestCase(unittest.TestCase):
    def test_example_1(self):
        self.assertEqual(Solution().findMaxConsecutiveOnes(['a','c','c','c','c','c','a','a','d','a']), 4)
    
    def test_example_2(self):
        self.assertEqual(Solution().findMaxConsecutiveOnes(['e','e','e','e','e','e','a','a','a','d']), 5)
    
    def test_example_3(self):
        self.assertEqual(Solution().findMaxConsecutiveOnes(['i','i','i','i','a','a','a','a','d','a']), 6)
    
    def test_example_4(self):
        self.assertEqual(Solution().findMaxConsecutiveOnes(['g','g','g','g','a','a','a','a','d','a']), 7)

if __name__ == '__main__':
    unittest.main()
################################################################

Solution:
['g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'd', 'a']

