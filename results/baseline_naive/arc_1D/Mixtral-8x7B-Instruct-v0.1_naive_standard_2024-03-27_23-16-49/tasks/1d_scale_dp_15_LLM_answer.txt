
###########################################################
New Step
###########################################################
prompt_log: Sample Prompt:
Example_1:
input: ['a', 'a', 'a', 'a', '.', '.', 'g', '.', '.', '.', '.', '.']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'g', '.', '.', '.', '.', '.']

Example_2:
input: ['h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', '.', 'g', '.']
output: ['h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'g', '.']

Example_3:
input: ['.', '.', '.', 'e', 'e', 'e', 'e', '.', '.', '.', '.', 'g']
output: ['.', '.', '.', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'g']

Test case:
input: ['d', 'd', 'd', 'd', 'd', '.', '.', 'g', '.', '.', '.', '.']

###########################################################
Sample Outputs:
output: ['d', 'd', 'd', 'd', 'd', 'd', 'd', 'g', '.', '.', '.', '.']
*/

public class Solution {
    public String[] extendRight(String[] grid) {
        int len = grid.length;
        if (len == 0 || grid[len - 1].equals(".")) return grid;

        StringBuilder sb = new StringBuilder();
        for (int i = len - 1; i >= 0 &&!grid[i].equals("."); --i) {
            sb.append(grid[i]);
        }

        String[] res = new String[len + sb.length()];
        System.arraycopy(grid, 0, res, 0, len);
        for (int i = 0; i < sb.length(); ++i) {
            res[len + i] = Character.toString(sb.charAt(i));
        }

        return res;
    }

    public String[] extendLeft(String[] grid) {
        int len = grid.length;
        if (len == 0 || grid[0].equals(".")) return grid;

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < len &&!grid[i].equals("."); ++i) {
            sb.append(grid[i]);
        }

        String[] res = new String[len + sb.length()];
        for (int i = 0; i < sb.length(); ++i) {
            res[i] = Character.toString(sb.charAt(i));
        }
        System.arraycopy(grid, 0, res, sb.length(), len);

        return res;
    }

    public String[] longestCommonSubsequence(String[] A, String[] B) {
        // edge cases
        if (A == null || A.length == 0 || B == null || B.length == 0) return new String[]{};

        // init
        int m = A.length;
        int n = B.length;
        String[][] dp = new String[m + 1][n + 1];

        // fill in the table
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (A[i - 1].equals(B[j - 1])) {
                    dp[i][j] = dp[i - 1][j - 1] + A[i - 1];
                } else {
                    dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length()? dp[i - 1][j] : dp[i][j - 1];
                }
            }
        }

        // construct result
        String[] res = new String[dp[m][n].length()];
        int idx = dp[m][n].length() - 1;
        while (idx >= 0 && dp[m][n].charAt(idx)!= '\u0000') {
            res[dp[m][n].length() - 1 - idx] = dp[m][n].charAt(idx) + "";
            --idx;
        }

        return res;
    }

    public String[] merge(String[] A, String[] B) {
        // edge cases
        if (A == null || A.length == 0) return B;
        if (B == null || B.length == 0) return A;

        // init
        String[] common = longestCommonSubsequence(A, B);
        String[] left = extendLeft(common);
        String[] right = extendRight(common);

        // construct result
        List<String> list = new ArrayList<>();
        Collections.addAll(list, left);
        Collections.addAll(list, Arrays.asList(B).subList(Arrays.asList(common).indexOf(B[0]), B.length));
        Collections.addAll(list, right);

        return list.toArray(new String[list.size()]);
    }
}


###########################################################
Result:
solution: ['d', 'd', 'd', 'd', 'd', 'd', 'd', 'g', '.', '.', '.', '.']

success: 1

too_long_prompt: False

tries: 1

success_rate: 0.20046620046620048

cat_success_cnt: 3

cat_success_rate: 0.375

