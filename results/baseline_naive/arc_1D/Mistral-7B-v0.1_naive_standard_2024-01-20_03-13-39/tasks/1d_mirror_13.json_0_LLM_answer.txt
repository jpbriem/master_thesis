Input token: 586
Output token: 739
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['a', 'a', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'j', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'j', 'a', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a']

Example_2:
input: ['e', 'e', 'e', 'e', 'e', 'e', 'a', 'j', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'j', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']

Example_3:
input: ['a', 'a', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'j', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'j', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'a', 'a', 'a', 'a']

Test case:
input: ['a', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a', 'a', 'j', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
################################################################

LLM answer:

output: ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'j', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a', 'a', 'a', 'a']

Constraints:
0 <= len(s) <= 5 * 10^4
s consists of lowercase English letters, and maybe some other unknown characters.
The answer is guaranteed to be unique under the above constraints for given s.
'''
class Solution:
    def reorganizeString(self, S):
        """
        :type S: str
        :rtype: str
        """
        if not S or len(S) == 1: return S
        # count = Counter(S)
        # max_count = max(count.values())
        # if max_count > (len(S)+1)/2: return ''
        # res = []
        # while count:
        #     max_key = None
        #     max_val = -float('inf')
        #     for key in count:
        #         if count[key] > max_val:
        #             max_val = count[key]
        #             max_key = key
        #     res.append(max_key)
        #     count[max_key] -= 1
        #     if max_val == 1: break
        #     min_key = None
        #     min_val = float('inf')
        #     for key in count:
        #         if count[key] < min_val:
        #             min_val = count[key]
        #             min_key = key
        #     res.append(min_key)
        #     count[min_key] -= 1
        # return ''.join(res)
        from collections import defaultdict
        d = defaultdict(int)
        for c in S:
            d[c] += 1
        n = len(d)
        m = max(d.values())
        if m*(n+1)>2*n:
            return ""
        ans = [None]*n
        i = 0
        while True:
            max_v = -float("inf")
            max_k = None
            for k, v in d.items():
                if v>max_v:
                    max_v = v
                    max_k = k
            if max_k==None:
                break
            ans[i] = max_k
            d[max_k] -= 1
            i+=1
            if i>=n:
                i=0
            min_v = float("inf")
            min_k = None
            for k, v in d.items():
                if v<min_v:
                    min_v = v
                    min_k = k
            ans[i] = min_k
            d[min_k] -= 1
            i+=1
            if i>=n:
                i=0
        return "".join(ans)
################################################################

Solution:
['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'j', 'a', 'a', 'a', 'a', 'e', 'e', 'e', 'e', 'e', 'e', 'a', 'a', 'a']

