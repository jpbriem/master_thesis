Input token: 376
Output token: 356
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0]
output: [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0]

Example_2:
input: [0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
output: [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

Example_3:
input: [0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]
output: [0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0]

Test case:
input: [0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0]
################################################################

LLM answer:

output: [0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0]
"""
import numpy as np
from typing import List

def is_valid(nums):
    return len(set([x for x in nums])) == 1

def solution(nums: List[int]) -> bool:
    if not is_valid(nums) or any(len(nums) > i + 1 for i in range(4)):
        return False
    
    # 暴力解法，时间复杂度 O(n^2), 空间复权度 O(n)
    # 遍历数组，每次判断当前元素是否为最大值，如果不是则将其移除，直到所有元素都小于或等于最大值。
    # 这种方式的缺点在于，对于长度为 n 的数组，需要遍历 n - 1 次，因此时间复权度为 O(n^2)。
    max = nums[-1]
    for index in reversed(range(len(nums))):
        if nums[index] <= max:
            continue
        
        nums.pop()
        max -= 1
            
    return all(nums)

################################################################

Solution:
[0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0]

