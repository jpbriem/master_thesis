Input token: 679
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', '.', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'g', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.']

Example_2:
input: ['.', '.', '.', 'c', 'c', 'c', 'c', 'a', 'c', 'h', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'd', 'c', 'c', 'c', '.', '.', '.', '.']
output: ['.', '.', '.', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '.', '.', '.', '.']

Example_3:
input: ['.', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'g', 'a', 'a', 'a', 'e', 'a', 'a', 'a', 'a', 'a', 'a', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', '.', '.', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'a', 'g', 'g', 'g', 'b', 'g', 'a', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.']
"""

import re
from typing import List, Optional


class Solution:
    def transform(self, grid: List[str]) -> None:
        """Do not return anything, modify grid in-place instead."""
        for i in range(len(grid)):
            if "." == grid[i]:
                continue
            elif grid[i] == "g":
                self._transform_g(grid, i)
            else:
                self._transform_other(grid, i)

    @staticmethod
    def _transform_g(grid: List[str], index):
        # 找到最近的 g，并将其变成.
        left = right = up = down = -1
        while True:
            if (index + 1 < len(grid)) and ("g" == grid[index+1] or ".") \
                    and ((left >= 0 and grid[left]!= "g") or left == -1):
                left += 1
            if (index - 1 > 0) and ("g" == grid[index-1] or ".") \
                    and ((right >= 0 and grid[right]!= "g") or right == -1):
                right -= 1
            if (index % 8 == 7) and ("g" == grid[(index-1)//8*8] or ".") \
                    and ((up >= 0 and grid[up]!= "g") or up == -1):
                up -= 1
            if (index // 8 == 0) and ("g" == grid[(index+1)//8*8] or ".") \
                    and ((down >= 0 and grid[down]!= "g") or down == -1):
                down += 1
            if left == -1 and right == -1 and up == -1 and down == -1:
                break
            if left >= 0 and right >= 0 and up >= 0 and down >= 0:
                break
            if left >= 0 and right >= 0 and up >= 0 and down == -1:
                break
            if left >= 0 and right >= 0 and up == -1 and down >= 0:
                break
            if left >= 0 and right == -1 and up >= 0 and down >= 0:
                break
            if left >= 0 and right == -1 and up == -1 and down >= 0:
                break
            if left >= 0 and right == -1 and up >= 0 and down == -1:
                break
            if left >= 0 and right == -1 and up == -1 and down == -1:
                break
            if left == -1 and right >= 0 and up >= 0 and down >= 0:
                break
            if left == -1 and right >= 0 and up == -1 and down >= 0:
                break
            if left == -1 and right >= 0 and up >= 0 and down == -1:
                break
            if left == -1 and right >= 0 and up == -1 and down == -1:
                break
            if left == -1 and right == -1 and up >= 0 and down >= 0:
                break
            if left == -1 and right == -1 and up == -1 and down >= 0:
                break
            if left == -1 and right == -1 and up >= 0 and down == -1:
                break
            if left == -1 and right == -1 and up == -1 and down == -1:
                break
            if left == -1 and right == -1 and up == -1 and down == -1:
                break
            if left == -1 and right == -1 and up == -1 and down == -1:
                break
            if left == -1 and right == -1 and up == -1 and down == -1:
                break
            if left == -1 and right == -1 and up == -1 and down == -1:
                break
            if left
################################################################

Solution:
['.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.']

