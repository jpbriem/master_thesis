Input token: 501
Output token: 443
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', '.', '.', '.', '.', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', '.', '.', '.', '.', 'c', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'c', '.']

Example_2:
input: ['.', '.', '.', '.', '.', '.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', '.', '.', 'c', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'c', '.']

Example_3:
input: ['.', '.', '.', 'e', 'e', 'e', 'e', 'e', 'e', 'e', '.', '.', '.', '.', '.', '.', '.', '.', 'c', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'c', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', '.', '.', '.', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', '.', '.', '.', '.', 'c', '.']
################################################################

LLM answer:

output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'c', '.']
"""

import re
from typing import List, Optional


class Solution:
    def restoreString(self, s: str) -> str:
        """
        1 <= s.length <= 500
        s consists of lowercase English letters, digits, and the characters ".", "?".
        There is exactly one character that appears twice in s.
        All other characters each appear at most once in s.
        """
        # Runtime: 48 ms, faster than 97.60% of Python3 online submissions for Restore Sequence.
        # Memory Usage: 13.9 MB, less than 100.00% of Python3 online submissions for Restore Sequence.
        if not s or len(s) == 1:
            return s

        char = None
        count = 0
        for c in set(s):
            if s.count(c) > 1:
                char = c
                break
        else:
            raise ValueError("No duplicate found")

        # find all occurences of `char`
        matches = re.findall(f"\w{char}", s)
        if len(matches)!= 2:
            raise ValueError("Expected two occurrences of {}".format(char))

        # replace first occurrence with `.`
        s = s[:matches[0].start()] + "." + s[matches[0].end():]
        # replace second occurrence with `.`
        s = s[:matches[-1].start()] + "." + s[matches[-1].end:]

        return s

################################################################

Solution:
['.', '.', '.', '.', '.', '.', '.', '.', '.', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'c', '.']

