Input token: 422
Output token: 582
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'c', 'c', 'c', 'c', 'c', '.', '.', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', 'i', '.', '.', '.', 'c', 'c', 'c', 'c', 'c', '.', '.', '.', '.']

Example_2:
input: ['.', '.', '.', '.', 'b', 'b', 'b', 'b', 'b', 'b', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'i', '.', 'b', 'b', 'b', 'b', 'b', 'b', '.', '.', '.']

Example_3:
input: ['.', '.', '.', '.', '.', '.', 'd', 'd', 'd', 'd', 'd', 'd', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'i', '.', 'd', 'd', 'd', 'd', 'd', 'd', '.']

Test case:
input: ['a', 'a', 'a', 'a', 'a', 'a', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', '.', '.', '.', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'a']
"""

import collections
from typing import List, Tuple


class Solution(object):
    def findPath(self, grid: List[List[str]], start: List[int], end: List[int]) -> bool:
        """
        找到从start到end的路径，返回True/False
        :param grid: 矩阵
        :param start: 起点
        :param end: 终点
        :return: True/False
        """
        if not self._isValid(grid) or not self._isInRange(grid, start) or not self._isInRange(grid, end):
            return False

        queue = collections.deque()
        visited = set()
        queue.append((start, []))
        while queue:
            cur_pos, path = queue.popleft()
            if cur_pos == end:
                return True
            for i in range(-1, 2):
                for j in range(-1, 2):
                    new_pos = (cur_pos[0] + i, cur_pos[1] + j)
                    if self._isValid(grid, new_pos) \
                            and self._isWalkable(grid, new_pos) \
                            and new_pos not in visited:
                        visited.add(new_pos)
                        queue.append((new_pos, path + [(cur_pos[0], cur_pos[1]), (i, j)])))
        return False

    @staticmethod
    def _isValid(grid, pos=None):
        if pos is None:
            return len(grid) > 0 and all([len(row) > 0 for row in grid])
        else:
            return 0 <= pos[0] < len(grid) and 0 <= pos[1] < len(grid[0])

    @staticmethod
    def _isInRange(grid, pos):
        return 0 <= pos[0] < len(grid) and 0 <= pos[1] < len(grid[0])

    @staticmethod
    def _isWalkable(grid, pos):
        return grid[pos[0]][pos[1]]!= '#'

################################################################

Solution:
['.', '.', '.', '.', '.', '.', '.', 'i', '.', 'a', 'a', 'a', 'a', 'a', 'a', '.', '.', '.', '.', '.', '.', '.']

