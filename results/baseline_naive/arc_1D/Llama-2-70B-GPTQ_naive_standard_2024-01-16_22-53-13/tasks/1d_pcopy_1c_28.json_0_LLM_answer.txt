Input token: 580
Output token: 675
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'g', 'g', 'g', '.', '.', '.', 'g', '.', '.', '.', '.', 'g', '.', '.', '.', 'g', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'g', 'g', 'g', '.', '.', 'g', 'g', 'g', '.', '.', 'g', 'g', 'g', '.', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_2:
input: ['.', '.', 'f', 'f', 'f', '.', '.', '.', 'f', '.', '.', '.', '.', '.', 'f', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', 'f', 'f', 'f', '.', '.', 'f', 'f', 'f', '.', '.', '.', 'f', 'f', 'f', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', 'i', 'i', 'i', '.', '.', 'i', '.', '.', '.', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'i', 'i', 'i', '.', 'i', 'i', 'i', '.', '.', 'i', 'i', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', 'g', 'g', 'g', '.', '.', '.', 'g', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', 'g', 'g', 'g', '.', '.', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
"""

import collections


class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[str]
        :rtype: int
        """
        
        # 2018/7/4
        # O(n) time complexity
        # O(n) space complexity
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        perimeters = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '.':
                    continue
                else:
                    perimeter = self._islandPerimeter(grid, i, j, directions)
                    perimeters.append(perimeter)
        return sum(perimeters)
    
    def _islandPerimeter(self, grid, x, y, directions):
        perimeter = 0
        visited = set()
        queue = collections.deque([])
        queue.append((x, y))
        while len(queue) > 0:
            x, y = queue.popleft()
            if not ((x >= 0 and x < len(grid)) and (y >= 0 and y < len(grid[0]))):
                continue
            
            if grid[x][y]!= '.':
                perimeter += 4
                for dx, dy in directions:
                    newX = x + dx
                    newY = y + dy
                    if not ((newX >= 0 and newX < len(grid)) and (newY >= 0 and newY < len(grid[0]))):
                        continue
                    if grid[newX][newY] == '.' or (newX, newY) in visited:
                        continue
                    visited.add((newX, newY))
                    queue.append((newX, newY))
            elif grid[x][y] == '.':
                perimeter += 1
                for dx, dy in directions:
                    newX = x + dx
                    newY = y + dy
                    if not ((newX >= 0 and newX < len(grid)) and (newY >= 0 and newY < len(grid[0]))):
                        continue
                    if grid[newX][newY] == '.':
                        continue
                    visited.add((newX, newY))
                    queue.append((newX, newY))
        return perimeter

################################################################

Solution:
['.', '.', 'g', 'g', 'g', '.', '.', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

