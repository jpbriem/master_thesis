Input token: 560
Output token: 398
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'e', '.', '.', '.', 'e', 'e', 'e', '.', 'e', 'e', '.', 'e', 'e', 'e', '.', '.', 'e', 'e', 'e', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'd', '.', '.', '.', 'c', 'c', 'c', '.', 'a', 'a', '.', 'c', 'c', 'c', '.', '.', 'c', 'c', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_2:
input: ['.', 'e', 'e', '.', '.', '.', 'e', 'e', 'e', '.', 'e', '.', '.', '.', 'e', 'e', '.', '.', 'e', 'e', 'e', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', 'a', 'a', '.', '.', '.', 'c', 'c', 'c', '.', 'd', '.', '.', '.', 'a', 'a', '.', '.', 'c', 'c', 'c', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Example_3:
input: ['.', '.', '.', 'e', 'e', '.', '.', 'e', 'e', 'e', '.', 'e', '.', 'e', '.', '.', 'e', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
output: ['.', '.', '.', 'a', 'a', '.', '.', 'c', 'c', 'c', '.', 'd', '.', 'd', '.', '.', 'd', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

Test case:
input: ['.', '.', '.', 'e', 'e', 'e', '.', 'e', '.', 'e', 'e', '.', '.', '.', 'e', 'e', 'e', '.', 'e', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', 'b', 'b', 'b', '.', 'f', '.', 'g', 'g', '.', '.', '.', 'h', 'h', 'h', '.', 'i', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
"""

import collections


class Solution(object):
    def transform(self, grid):
        """
        :type grid: List[str]
        :rtype: List[str]
        """
        
        # 0. check inputs & outputs
        assert len(grid) == 4 * (len(grid) - 1), "The length of each side must be a multiple of four."
        assert all([all(row in ['e','.']) for row in grid]), "Each cell can only contain either '.' or 'e'."
        
        # 1. process
        directions = [(0,-1),(0,1),(1,0),(-1,0)]
        queue = collections.deque()
        for i in range(len(grid)):
            if grid[i][0]=='.':
                queue.append((i,[0]))
                
        while queue:
            x,y=queue.popleft()
            
            for dx,dy in directions:
                nx,ny=(x+dx, y+dy)
                if not (0<=nx<len(grid)) or not (0<=ny<len(len(grid))) or grid[nx][ny]!='.': continue
                queue.append((nx,ny))
                grid[nx][ny]=grid[x][y]+'_'+grid[x][y]
                
        return grid

################################################################

Solution:
['.', '.', '.', 'c', 'c', 'c', '.', 'd', '.', 'a', 'a', '.', '.', '.', 'c', 'c', 'c', '.', 'd', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']

