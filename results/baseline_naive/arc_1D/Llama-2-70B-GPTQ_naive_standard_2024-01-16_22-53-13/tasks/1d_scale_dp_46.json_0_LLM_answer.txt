Input token: 445
Output token: 537
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['d', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', '.', '.', 'i', '.']
output: ['d', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'i', '.']

Example_2:
input: ['h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', '.', '.', '.', '.', 'i']
output: ['h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'h', 'i']

Example_3:
input: ['.', '.', '.', '.', 'f', 'f', 'f', 'f', 'f', '.', '.', '.', '.', '.', '.', '.', '.', 'i', '.', '.']
output: ['.', '.', '.', '.', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'i', '.', '.']

Test case:
input: ['.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', '.', '.', '.', '.', '.', '.', '.', '.', 'i', '.']
################################################################

LLM answer:

output: ['.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'i', '.']
"""

# Definition for a Node.
class Node(object):
    def __init__(self, val, isEnd):
        self.val = val
        self.isEnd = isEnd
        self.next = []


class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums or len(nums) == 0:
            return 0
        
        # build linked list
        head = None
        for i in range(len(nums)):
            node = Node(nums[i], False)
            
            if head is None:
                head = node
                
            else:
                lastNode = head
                while True:
                    if lastNode.next!= []:
                        lastNode = lastNode.next[-1]
                    
                    elif lastNode.val + 1 == node.val:
                        lastNode.next.append(node)
                        break
                    
                    else:
                        lastNode.next.append(None)
                        lastNode = lastNode.next[-1]
                        continue
                
                break
        
        maxLength = 0
        currentLength = 0
        startIndex = -1
        endIndex = -1
        for i in range(len(head.next)-1,-1,-1):
            if head.next[i].isEnd:
                currentLength += 1
                if currentLength > maxLength:
                    maxLength = currentLength
                    startIndex = i+1
                    endIndex = len(head.next)-1
                
                if currentLength >= maxLength:
                    startIndex = i+1
                    endIndex = len(head.next)-1
                
            else:
                currentLength -= 1
                if currentLength < 0:
                    currentLength = 0
                
        return (endIndex - startIndex) + 1
################################################################

Solution:
['.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'i', '.']

