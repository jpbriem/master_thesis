Input token: 251
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', 'f', 'b', 'b', 'b', 'b', '.', '.', '.', '.', '.']
output: ['.', 'b', 'b', 'b', 'b', 'f', '.', '.', '.', '.', '.']

Example_2:
input: ['.', '.', '.', '.', 'c', 'd', 'd', 'd', 'd', '.', '.']
output: ['.', '.', '.', '.', 'd', 'd', 'd', 'd', 'c', '.', '.']

Example_3:
input: ['.', '.', '.', '.', '.', '.', '.', 'e', 'f', 'f', '.']
output: ['.', '.', '.', '.', '.', '.', '.', 'f', 'f', 'e', '.']

Test case:
input: ['.', '.', '.', 'e', 'd', 'd', '.', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', 'd', 'd', '.', '.', '.', '.', '.', '.']
"""
from typing import List, Optional
import collections


class Solution(object):
    def reverseWords(self, s: str) -> None:
        """
        :type s: str
        :rtype: None
        """
        if not isinstance(s, str):
            return
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复权为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终再重新组合。
        words = s.split()
        for word in words:
            self._reverseWord(word)
            
        # 优化版本，时间复杂度为 O(n)，空间复权为 O(n)。
        # 先将字符串分割成多个单词，然后按照单词的长度从小到大排序，在这之前我们需要判断当前单词是否可以被反转，如果不能则直接返回，因此时间复杂度为 O(n)；
        # 然后根据排序结果来遍历，并对每个单词进行反转，最终再重新组合。
        sorted_words = list(sorted(set([w[0] for w in words]), key=len))
        for i in range(len(sorted_words)):
            self._reverseWord(sorted_words[i])
    
    def _reverseWord(self, word: str) -> None:
        """
        :type word: str
        :rtype: None
        """
        if len(word) == 0 or word[-1]!= '.':
            return
        
        # 使用双指针实现，时间复杂度为 O(n)，空间复权为 O(1)。
        # 首先定义两个变量，分别表示左边和右边，初始值设置为 -1，代表向前移动，因此时间复杂度为 O(n)；
        # 然后开始逐个元素进行比较，如果左边位于右边之前，则交换两者，然后继续比较，直到达到尾部或者左边位于右边之前，才会返回。
        left, right = -1, -1
        while left < len(word)-1:
            if word[left] > word[right]:
                left += 1
            else:
                right -= 1
                
            if left >= right:
                break
        
        # 若左边位于右边之前，则交换两者，然后继续比较，直到达到尾部或者左边位于右边之前，才会返回。
        if left >= right:
            word[left], word[right] = word[right], word[left]
        
        # 若左边位于右边之前，则交换两者，然后继续比较，直到达到尾部或者左边位于右边之前，才会返回。
        if left >= right:
            word[:left+1], word[right:] = word[right:], word[:right+1]
        
        # 若左边位于右边之前，则交换两者，然后继续比较，直到达到尾部或者左边位于右边之前，才会返回。
        if left >= right:
            word[:left+1], word[right:] = word[right:], word[:right+1]
        
        # 若左边位于右边之前，则交换两者，然后继续比�
################################################################

Solution:
['.', '.', '.', 'd', 'd', 'e', '.', '.', '.', '.', '.']

