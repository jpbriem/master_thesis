Input token: 190
Output token: 327
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['g', 'g', 'g', '.', '.', 'f', '.']
output: ['.', '.', 'g', 'g', 'g', 'f', '.']

Example_2:
input: ['c', 'c', 'c', '.', '.', 'f', '.']
output: ['.', '.', 'c', 'c', 'c', 'f', '.']

Example_3:
input: ['h', 'h', 'h', '.', '.', 'f', '.']
output: ['.', '.', 'h', 'h', 'h', 'f', '.']

Test case:
input: ['e', 'e', 'e', '.', '.', 'f', '.']
################################################################

LLM answer:

output: ['.', '.', 'e', 'e', 'e', 'f', '.']
"""
import collections
from typing import List, Optional


def get_next(current_char: str) -> int:
    if current_char == ".":
        return 0
    elif current_char in "fgh":
        return -1
    else:
        return 1


class Solution:
    def reverseWords(self, s: str) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        words = []
        for char in s:
            if char == ".":
                break
            elif char in "fgh":
                continue
            else:
                words.append(char)
        while len(words):
            last_word = words[-1]
            next_index = get_next(last_word)
            if next_index < 0 or next_index >= len(s):
                break
            new_word = s[next_index]
            words.pop()
            s[next_index], s[len(s)-1] = s[len(s)-1], s[next_index]


if __name__ == "__main__":
    solution = Solution()
    print("Input:")
    print(solution.reverseWords("eelofkcsdf"))

################################################################

Solution:
['.', '.', 'e', 'e', 'e', 'f', '.']

