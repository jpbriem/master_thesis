Input token: 348
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'g', 'g', 'g', 'g', 'g', '.', '.']
output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'g', '.', '.', '.', 'g', '.', '.']

Example_2:
input: ['.', '.', '.', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', '.', '.', '.']
output: ['.', '.', '.', 'g', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'g', '.', '.', '.']

Example_3:
input: ['.', '.', '.', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', '.', '.', '.']
output: ['.', '.', '.', 'b', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'b', '.', '.', '.']

Test case:
input: ['.', '.', '.', '.', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', '.', '.', '.', '.']
################################################################

LLM answer:

output: ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']
"""
from typing import List, Optional
import collections


class Solution(object):
    def reverseWords(self, s: str) -> None:
        """
        :type s: str
        :rtype: None
        """
        if not isinstance(s, str):
            return
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复杂度为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终再重新组合。
        words = s.split()
        for word in words:
            self._reverseWord(word)
            
        # 使用双指针，时间复杂度为 O(n)，空间复杂度为 O(1)。
        # 先将字符串分割成多个单词，然后在两个指针之间交换位置，直到所有的单词都被移动过来。
        i = j = len(words) - 1
        while i >= 0 or j < len(words):
            if i > 0 and j < len(words):
                tmp = words[i]
                words[i], words[j] = words[j], tmp
                
            i -= 1
            j += 1
    
    def _reverseWord(self, word: str) -> None:
        """
        :type word: str
        :rtype: None
        """
        if not isinstance(word, str):
            return
        
        # 使用双指针，时间复杂度为 O(n)，空间复杂度为 O(1)。
        # 首先判断当前单词是否已经完全反转过了，如果没有则需要将其中的元素反转，并且记录下该单词的长度。
        i = 0
        while i < len(word):
            if word[i] == word[-1]:
                break
            
            i += 1
            
        if i!= len(word):
            self.__reverseSubString(word[:i])
            self.__reverseSubString(word[i:])
            
    def __reverseSubString(self, subStr: str) -> None:
        """
        :type subStr: str
        :rtype: None
        """
        if not isinstance(subStr, str):
            return
        
        # 使用双指针，时间复杂度为 O(n)，空间复权为 O(1)。
        # 首先判定当前子串是否已经完全反转过了，如果没有则需要将其中的元素反转，并且记录下该子串的长度。
        i = 0
        while i < len(subStr):
            if subStr[i] == subStr[-1]:
                break
            
            i += 1
            
        if i!= len(subStr):
            self.__reverseSubString(subStr[:i])
            self.__reverseSubString(subStr[i:])
            
    def reverseWordsExceptLast(self, s: str) -> None:
        """
        :type s: str
        :rtype: None
        """
        if not isinstance(s, str):
            return
        
        # 暴力解法，时间复杂度为 O(n^2), 空间复杂度为 O(n)。
        # 将字符串分割成多个单词，然后遍历每一个单词，对其进行反转，最终再重新组合。
        words = s.split()
        for word in words:
            self._reverseWordExceptLast(
################################################################

Solution:
['.', '.', '.', '.', 'd', '.', '.', '.', '.', '.', '.', '.', 'd', '.', '.', '.', '.']

