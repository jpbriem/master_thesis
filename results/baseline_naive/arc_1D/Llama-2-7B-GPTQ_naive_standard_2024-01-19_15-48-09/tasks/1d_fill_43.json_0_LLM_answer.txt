Input token: 292
Output token: 755
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: ['a', 'a', 'c', 'a', 'a', 'a', 'a', 'c', 'a', 'a', 'a']
output: ['a', 'a', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'a', 'a']

Example_2:
input: ['a', 'a', 'a', 'a', 'd', 'a', 'a', 'a', 'd', 'a', 'a']
output: ['a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 'd', 'a', 'a']

Example_3:
input: ['c', 'a', 'a', 'a', 'a', 'a', 'c', 'a', 'a', 'a', 'a']
output: ['c', 'c', 'c', 'c', 'c', 'c', 'c', 'a', 'a', 'a', 'a']

Test case:
input: ['f', 'a', 'a', 'a', 'f', 'a', 'a', 'a', 'a', 'a', 'a']
################################################################

LLM answer:

output: ['f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f']
"""
import sys
from collections import deque, defaultdict

class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        
        if not isinstance(s,str) or len(s) == 0: return ''
        
        # 暴力解法，时间复杂度为O(n^2),空间复权为O(n)
        # 先将字符串分割成多个单词，然后遍历每一个单词，判断是否需要反转。
        # 如果需要反转，则反转该单词，并且将其添加到最终的结果中。
        words = [x for x in s]
        res = []
        for word in words:
            if word[0].isupper():
                res += [word[::-1]]
            
        return "".join(res)
    
    def reverseWordsEx(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not isinstance(s,str) or len(s) == 0: return ''
        
        # 使用双指针实现，时间复权为O(n)，空间复权为O(1)
        # 首先定义两个变量，分别表示当前位置和下标，这样可以方便地计算下标值。
        start, end = 0, -1
        while True:
            if end < 0: break
            
            # 若当前位置不在字符串中，说明已经到达了尾部，直接返回。
            if s[end]!= '\0': break
            
            # 若当前位置大于或等于字符串长度，说明已经到达了头部，直接返回。
            elif s[start] >= ord('z'): break
                
            # 若当前位置小于字符串长度，说明还没有到达尾部，进行下标运算。
            else:
                index = (ord(s[start]) + ord("a") - ord("A")) % len(s)
                if index > end:
                    index -= len(s)
                
                # 若当前位置与下标相同，说明已经到达了尾部，直接返回。
                if index == end: break
                
                # 若当前位置小于字符串长度，说明还没有到达尾部，进行下标运算。
                else:
                    temp = s[index]
                    s[index] = s[end]
                    s[end] = temp
                    end += 1
                
        return ""

################################################################

Solution:
['f', 'f', 'f', 'f', 'f', 'a', 'a', 'a', 'a', 'a', 'a']

