Input token: 376
Output token: 694
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[1, 8, 8, 7, 7, 8], [1, 1, 7, 7, 1, 8], [7, 1, 1, 7, 7, 8]]
output: [[1, 8, 8, 5, 5, 8], [1, 1, 5, 5, 1, 8], [5, 1, 1, 5, 5, 8]]

Example_2:
input: [[7, 7, 7, 1], [1, 8, 1, 7], [7, 1, 1, 7]]
output: [[5, 5, 5, 1], [1, 8, 1, 5], [5, 1, 1, 5]]

Example_3:
input: [[1, 8, 1, 7, 1], [7, 8, 8, 1, 1], [7, 1, 8, 8, 7]]
output: [[1, 8, 1, 5, 1], [5, 8, 8, 1, 1], [5, 1, 8, 8, 5]]

Test case:
input: [[1, 7, 7, 1, 7], [8, 1, 7, 7, 7], [8, 7, 1, 7, 8]]
################################################################

LLM answer:

output: [[1, 7, 7, 4, 4], [4, 1, 7, 7, 4], [4, 7, 1, 7, 4]]

Constraints:
1 <= N <= 10^5
1 <= M <= 10^5
1 <= A[i][j] <= 9
 */
public class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return new int[0][];
        int m = matrix.length;
        int n = matrix[0].length;
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (matrix[i][j] == 0) {
                    queue.offer(i * n + j);
                } else {
                    matrix[i][j] = Integer.MAX_VALUE;
                }
            }
        }
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                int index = queue.poll();
                int x = index / n;
                int y = index % n;
                if (x > 0 && matrix[x - 1][y]!= Integer.MAX_VALUE) {
                    matrix[x - 1][y] = Math.min(matrix[x - 1][y], matrix[x][y] + 1);
                    queue.offer((x - 1) * n + y);
                }
                if (x < m - 1 && matrix[x + 1][y]!= Integer.MAX_VALUE) {
                    matrix[x + 1][y] = Math.min(matrix[x + 1][y], matrix[x][y] + 1);
                    queue.offer((x + 1) * n + y);
                }
                if (y > 0 && matrix[x][y - 1]!= Integer.MAX_VALUE) {
                    matrix[x][y - 1] = Math.min(matrix[x][y - 1], matrix[x][y] + 1);
                    queue.offer(x * n + y - 1);
                }
                if (y < n - 1 && matrix[x][y + 1]!= Integer.MAX_VALUE) {
                    matrix[x][y + 1] = Math.min(matrix[x][y + 1], matrix[x][y] + 1);
                    queue.offer(x * n + y + 1);
                }
            }
        }
        return matrix;
    }
}
################################################################

Solution:
[[1, 5, 5, 1, 5], [8, 1, 5, 5, 5], [8, 5, 1, 5, 8]]

