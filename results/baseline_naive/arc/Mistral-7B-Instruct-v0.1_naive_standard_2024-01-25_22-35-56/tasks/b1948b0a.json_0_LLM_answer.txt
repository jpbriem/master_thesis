Input token: 433
Output token: 363
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[6, 6, 7, 6], [6, 6, 7, 7], [7, 7, 6, 7]]
output: [[2, 2, 7, 2], [2, 2, 7, 7], [7, 7, 2, 7]]

Example_2:
input: [[7, 7, 7, 6], [6, 6, 7, 6], [7, 7, 6, 7], [7, 6, 7, 7], [7, 6, 7, 6], [6, 6, 6, 7]]
output: [[7, 7, 7, 2], [2, 2, 7, 2], [7, 7, 2, 7], [7, 2, 7, 7], [7, 2, 7, 2], [2, 2, 2, 7]]

Example_3:
input: [[7, 7, 6, 6, 6, 6], [6, 7, 6, 7, 7, 7], [7, 6, 7, 7, 6, 7]]
output: [[7, 7, 2, 2, 2, 2], [2, 7, 2, 7, 7, 7], [7, 2, 7, 7, 2, 7]]

Test case:
input: [[6, 7, 7, 6], [6, 7, 6, 7], [7, 7, 7, 6], [7, 6, 7, 6]]
################################################################

LLM answer:

output: [[4, 4, 7, 4], [4, 4, 7, 7], [7, 7, 4, 4], [4, 4, 4, 7]]

Constraints:
1 <= n <= 10^5
1 <= nums[i][j] <= 9

Solution:
class Solution {
public:
    vector<vector<int>> findPairsWithDistanceK(vector<vector<int>> nums, int k) {
        unordered_map<pair<int, int>, pair<int, int>> m;
        for (auto& p : nums) {
            auto it = m.find(make_pair(p[0], p[1]));
            if (it!= m.end()) {
                m[it->first].second += k;
                m[it->first].first -= k;
            } else {
                m[make_pair(p[0] - k, p[1] + k)] = make_pair(p[0], p[1]);
            }
        }
        vector<vector<int>> ans;
        for (auto& p : m) {
            if (p.second.first >= 0 && p.second.first < p.first + k && p.second.second >= 0 && p.second.second < p.first + k) {
                ans.push_back({p.second.first, p.second.second});
            }
        }
        return ans;
    }
};
################################################################

Solution:
[[2, 7, 7, 2], [2, 7, 2, 7], [7, 7, 7, 2], [7, 2, 7, 2]]

