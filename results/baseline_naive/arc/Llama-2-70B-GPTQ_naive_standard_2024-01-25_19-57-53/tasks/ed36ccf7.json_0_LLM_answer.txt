Input token: 316
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[9, 0, 0], [9, 9, 9], [9, 9, 9]]
output: [[0, 9, 9], [0, 9, 9], [9, 9, 9]]

Example_2:
input: [[6, 6, 6], [0, 0, 0], [6, 6, 0]]
output: [[6, 0, 0], [6, 0, 6], [6, 0, 6]]

Example_3:
input: [[0, 0, 9], [0, 0, 9], [9, 9, 9]]
output: [[9, 9, 9], [0, 0, 9], [0, 0, 9]]

Example_4:
input: [[2, 0, 2], [0, 0, 2], [0, 2, 2]]
output: [[2, 2, 2], [0, 0, 2], [2, 0, 0]]

Test case:
input: [[0, 0, 0], [5, 0, 0], [0, 5, 5]]
################################################################

LLM answer:

output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
"""

# @lc code=start
class Solution(object):
    def rotateIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: void Do not return anything, modify grid in-place instead.
        
        >>> solution = Solution()
        >>> grid = [[0, 0, 0], [5, 0, 0], [0, 5, 5]]
        >>> solution.rotateIsland(grid)
        >>> print(grid)
        [[0, 0, 0]
         [0, 0, 0]
         [0, 0, 0]]
        """
        if len(grid) == 0 or len(grid[0]) == 0:
            return None
            
        # find the first island
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j]:
                    self._rotate(grid, i, j)
                    
    def _rotate(self, grid, x, y):
        if not (x < len(grid)) or not (y < len(grid[x])):
            return False
        
        if not grid[x][y]:
            return False
        
        # find the leftmost point of this island
        while True:
            if x > 0 and not grid[x - 1][y]:
                break
            else:
                x -= 1
        
        # find the rightmost point of this island
        while True:
            if x + 1 >= len(grid):
                break
            elif not grid[x + 1][y]:
                break
            else:
                x += 1
        
        # find the topmost point of this island
        while True:
            if y > 0 and not grid[x][y - 1]:
                break
            else:
                y -= 1
        
        # find the bottommost point of this island
        while True:
            if y + 1 >= len(grid[x]):
                break
            elif not grid[x][y + 1]:
                break
            else:
                y += 1
        
        # rotate the island
        for i in range(x, x + 1, 1):
            for j in range(y, y + 1, 1):
                temp = grid[i][j]
                grid[i][j] = grid[x][y]
                grid[x][y] = temp
                y += 1
        
        # update the new position of the island
        x += 1
        y -= 1
        for i in range(x, x + 1, 1):
            for j in range(y, y + 1, 1):
                temp = grid[i][j]
                grid[i][j] = grid[x][y]
                grid[x][y] = temp
                x += 1
        
        # update the new position of the island
        x -= 1
        y += 1
        for i in range(x, x + 1, 1):
            for j in range(y, y + 1, 1):
                temp = grid[i][j]
                grid[i][j] = grid[x][y]
                grid[x][y] = temp
                y += 1
        
        # update the new position of the island
        x -= 1
        y -= 1
        for i in range(x, x + 1, 1):
            for j in range(y, y + 1, 1):
                temp = grid[i][j]
                grid[i][j] = grid[x][y]
                grid[x][y] = temp
                x -= 1
        
        # update the new position of the island
        x += 1
        y -= 1
        for i in range(x, x + 1, 1):
            for j in range(y, y + 1, 1):
                temp = grid[i][j]
                grid[i][j] = grid[x][y]
                grid[x][y] = temp
               
################################################################

Solution:
[[0, 0, 5], [0, 0, 5], [0, 5, 0]]

