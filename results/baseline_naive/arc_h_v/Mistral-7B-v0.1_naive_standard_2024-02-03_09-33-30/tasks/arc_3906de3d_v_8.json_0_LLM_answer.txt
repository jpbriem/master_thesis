Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 0, 3, 0, 3, 3, 3, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 3, 0], [0, 3, 0, 0, 9, 0, 0, 3, 0, 0], [0, 0, 0, 0, 9, 0, 0, 3, 0, 0], [0, 0, 9, 0, 9, 0, 0, 0, 0, 0], [0, 0, 9, 0, 9, 0, 0, 0, 9, 0], [0, 0, 9, 0, 9, 0, 9, 0, 9, 0], [0, 0, 9, 0, 9, 0, 9, 0, 9, 0]]
output: [[0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 9, 3, 9, 3, 3, 3, 3, 0], [0, 3, 9, 3, 9, 3, 9, 3, 3, 0], [0, 3, 9, 3, 9, 3, 9, 3, 3, 0], [0, 3, 9, 0, 9, 0, 0, 3, 9, 0], [0, 0, 0, 0, 9, 0, 0, 3, 9, 0], [0, 0, 0, 0, 9, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 0, 3, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 0]]
output: [[0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 9, 3, 0, 0], [0, 0, 3, 3, 3, 0, 9, 9, 0, 0], [0, 0, 0, 3, 0, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 3, 3, 3, 0, 3, 3, 0], [0, 0, 0, 0, 3, 3, 0, 3, 3, 0], [0, 0, 0, 0, 3, 0, 0, 3, 3, 0], [0, 0, 0, 0, 3, 0, 9, 3, 3, 0], [0, 0, 0, 0, 3, 0, 9, 3, 0, 0], [0, 0, 0, 0, 3, 0, 9, 0, 0, 0], [0, 0, 0, 9, 0, 0, 9, 0, 0, 0], [0, 0, 0, 9, 0, 9, 9, 0, 0, 0], [0, 0, 0, 9, 0, 9, 9, 9, 0, 0]]
output: [[0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 3, 3, 3, 9, 3, 3, 0], [0, 0, 0, 9, 3, 3, 9, 3, 3, 0], [0, 0, 0, 9, 3, 9, 9, 3, 3, 0], [0, 0, 0, 9, 3, 9, 9, 3, 3, 0], [0, 0, 0, 0, 3, 0, 9, 3, 0, 0], [0, 0, 0, 0, 3, 0, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 0, 3, 3, 3, 0, 0], [0, 0, 0, 3, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0]]
```

## Answer (4)

# Python 3, ~~78~~ 65 bytes

```
lambda a:[max(a[i][j]for i in range(len(a)))if j<len(a)-1else max(a[i][j+1])for j in range(len(a))]
```

Try it online!

Comment: `lambda a:[max(a[i][j]for i in range(len(a)))if j<len(a)-1else max(a[i][j+1])for j in range(len(a))]` saves 13 bytes.

Comment: @JonathanAllan Thanks for that! I'm not sure why I didn't think of that...

## Answer (3)

# Jelly, 10 bytes

```
Ṗ€ƊḢ⁼ịẋỤṪ
```

A monadic Link accepting a list of lists which yields a list of integers.

**Try it online!** Or see the test-suite.

### How?

The first line is a dyadic link taking a list of lists as its left argument and an integer as its right argument. It returns the maximum value from the given row or column.

```
Ṗ€ƊḢ⁼ịẋỤṪ - Link: list of lists, r; integer, c
Ṗ€         - pop each row                    e.g. [[0,3,3,3,3,3,3,3,3,0],[0,3,0,3,0,3,3,3,3,0],[0,3,0,3,0,3,0,3,3,0],[0,3,0,3,0,3,0,3,3,0],[0,3,0,0,9,0,0,3,0,0],[0,0,0,0,9,0,0,3,0,0],[0,0,9,0,9,0,0,0,0,0],[0,0,9,0,9,0,0,0,9,0],[0,0,9,0,9,0,9,0,9,0],[0,0,9,0,9,0,9,0,9,0]]
  Ɗ        - last two links as a monad:
    ị      - index into (these are the rows)
      ẋ    - repeat (this is the number of times to repeat the row)
       Ụ   - unzip (this is the number of columns)
         Ṫ - tail (this is the final result)
```

--------------------

# Jelly, 11 bytes

```
Ṗ€ƊḢ⁼ịẋỤṪḢ
```

A monadic Link accepting a list of lists which yields a list of integers.

**Try it online!** Or see the test-suite.

### How?

This works by finding the maximum value in each row and then repeating this value the appropriate number of times.

```
Ṗ€ƊḢ⁼ịẋỤṪḢ - Link: list of lists
Ṗ€           - pop each row                    e.g. [[0,3,3,3,3,3,3,3,3,0],[0,3,0,3,0,3,3,3,3,0],[0,3,0,3,0,3,0,3,3,0],[0,3,0,3,0,3,0,3,3,0],[0,3,0,0,9,0,0,3,0,0],[0,0,0,0,9,0,0,3,0,0],[0,0,9,0,9,0,0,0,0,0],[0,0,9,0,9,0,0,0,9,0],[0,0,9,0,9,0,9,0,9,0],[0,0,9,0,9,0,9,0,9,0]]
  Ɗ          - last three links as a monad:
    Ɗ        - last two links as a monad:
      ị      - index into (these are the rows)
        Ḣ    - head (this is the final result)
```

## Answer (3)

# JavaScript (ES6), 59 bytes

Expects a 2D array as input. Returns a 1D array with the results.

```
f=([x,y]=>(x=[...x].map((_,i)=>(y[i]||f(y)[i]))).filter(_=>_)&&x)
```

Try it online!

### Commented

```
f = (               // f is a recursive function taking:
  [x, y]            //   x[][] -> y[][]
  =>                 // return:
    (x = [...x].map( //   x[][] -> x[][]
      (_, i) =>      //   for each element at position i:
        (y[i] ||    //     if y[i] exists:
          f(y)[i]   //       use the corresponding element of f(y)
        )           //     else:
    ).filter(_ => _) //       filter out undefined elements
    && x             //       if any element remains:
)                    //
```

## Answer (2)

# Haskell, 54 bytes

```
import Data.List
p=mapM(\l->maximum$map l)
```

Try it online!

## Answer (2)

# C (gcc), 100 bytes

```
f(int*a){int b[10];b[0]=a[0][0];for(int i=1;i<10;++i)b[i]=a[i%10][i/10];return b;}
```

Try it online!

## Answer (2)

# R, 54 bytes

```
function(x)apply(x,1,max)+apply(x,2,max)
```

Try it online!

## Answer (2)

# Retina 0.8.2, 27 bytes

```
\d+
$*
^.*¶
$&
```

Try it online! Explanation: This solution uses the fact that the output can be represented as a single string of digits.

```
\d+
$*
```

Convert all numbers to their decimal representation.

```
^.*¶
$&
```

Join the lines together.

## Answer (2)

# Ruby, 41 bytes

```
->a{a.map{|r|r.map(&:max)}}
```

Try it online!

## Answer (2)

# Perl 5, 39 + 1 (-n) = 40 bytes

```
say map{$_=max($_)}@F
```

################################################################

Solution:
[[0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 9, 3, 3, 3, 0, 0], [0, 0, 0, 3, 9, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

