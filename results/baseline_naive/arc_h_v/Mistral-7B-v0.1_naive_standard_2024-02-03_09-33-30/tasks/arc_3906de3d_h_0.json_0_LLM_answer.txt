Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 1, 1, 1], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 1, 1, 1, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 1, 1, 1, 1], [2, 0, 0, 0, 0, 0, 1, 1, 1, 1], [2, 0, 0, 0, 0, 0, 0, 1, 1, 1], [2, 2, 2, 2, 2, 0, 0, 0, 0, 1], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 1], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 1, 1, 1, 0, 0, 0, 0], [2, 1, 1, 1, 1, 0, 0, 0, 0, 0], [2, 1, 1, 1, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 1, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 1, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 1, 1, 1], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 1, 1, 1, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 1, 1, 1, 1, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 1], [2, 0, 0, 0, 0, 0, 1, 1, 1, 1], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 1], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 1], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 1, 1, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 1, 1, 1], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~78~~ 69 bytes

```
lambda x:[[max(x[i][j]for i in range(len(x)))if j%2else min(x[i][j]for i in range(len(x)))]for j in range(len(x[0]))]
```

Try it online!

Comment: `min()` is a builtin function so you can save some bytes by using that instead of `sorted()[0]`. Also, I think you can use `range(len(x))` instead of `range(len(x)-1)`, since you're not actually using the last element anyway.

Comment: @JonathanFrech Thanks for the tips!

## Answer (3)

# Jelly, 5 bytes

```
ḶṪẎỤƊ
```

Try it online!

### How?

```
ḶṪẎỤƊ - Main link. Takes an argument A on the left
Ḷ      -   transpose A
 Ṫ     -   pop; discard the rightmost column
   Ɗ   -   last three links as a monad f(A):
  Ẏ    -       maximum over each row
   Ụ   -       minimum over each column
```

## Answer (3)

# JavaScript (ES6), 51 bytes

Expects **matrix** to be a two dimensional array. Returns a new matrix.

```
m=>m.map((r,y)=>(r=r.map((_,x)=>m[y][x^1]),r[~x]+r[x]))
```

Try it online!

--------------------

# JavaScript (ES6), 53 bytes

Expects **matrix** to be a one dimensional array. Returns a new matrix.

```
m=>m.map((r,y)=>(r=r.map((_,x)=>m[y][x^1]),r[~x]+r[x]))
```

Try it online!

## Answer (2)

# Haskell, 51 bytes

```
f m=[[maximum$zipWith max m$transpose m!!i|i<-[0..length m-1]]]
```

Try it online!

## Answer (2)

# C++ (gcc), 100 bytes

```
[](auto&a){int b[2];for(int i=0;i<a.size();i++)b[i]=*std::max_element(a[i].begin(),a[i].end());return{b};}
```

Try it online!

## Answer (2)

# R, 51 bytes

```
function(x)t(apply(x,1,max))+t(apply(x,1,min))
```

Try it online!

## Answer (2)

# Retina 0.8.2, 27 bytes

```
\d
$*
+`(\d)(.)
$1$2
```

Try it online! Link includes test cases. Explanation:

```
\d
$*
```

Convert all digits to stars.

```
+`(\d)(.)
$1$2
```

Replace every digit with its maximum or minimum value depending on whether it appears evenly or oddly in the original string.

## Answer (2)

# Charcoal, 16 bytes

```
Ｎθ≔⁰ηＦθ«≧ιη∨≦ιη≔⌈↷ι⟦✂ιη⁵‖⁴⟧≔⌊↷ι⟦✂ιη⁵‖⁴⟧≔η⊕η
```

Try it online! Link is to verbose version of code. Outputs as a list of lists. Explanation:

```
Ｎθ
```

Input the number of rows.

```
≔⁰η
```

Initialise the current row index to zero.

```
Ｆθ«
```

Loop over the rows.

```
≧ιη∨≦ιη
```

If this is the first or last row then...

```
≔⌈↷ι⟦✂ιη⁵‖⁴⟧
```

...take the maximum of the elements in the row.

```
≔⌊↷ι⟦✂ιη⁵‖⁴⟧
```

...otherwise take the minimum of the elements in the row.

```
≔η⊕η
```

Increment the current row index.

## Answer (2)

# Pyth, 10 bytes

```
hQMzTGQMzT
```

Try it here!

Explanation:

```
hQMzTGQMzT
hQ          Transpose the input
 M          Map over the columns
  z         Zip with the previous column
   T        Take the maximum
    GQ      And the minimum
     MzT    And zip them together
```

## Answer (2)

# Perl 5, 49 + 1 (-p) = 50 bytes

```
$_=$_;s/\d/($a[$_-$&1]>$a[$_]&&$a[$_])/$a[$_]/ge
```

Try it online!

## Answer (2)

# Java 8, ~~107~~ 106 bytes

```
m->{var r=new int[m.length][m[0].length];for(int i=0;i<m.length;i++){for(int j=0;j<m[0].length;j++)r[i][j]=Math.max(m[i][j],m[i][j^1]);}}
```

-1 byte thanks to *@ceilingcat*.

Try it online.

**Explanation:**

```
m->{                               // Method with integer matrix parameter and no return-type
  var r=                           //  Result-array, initialized with the length of the input-matrix
                                   //  and the length of the inner arrays
    new int[m.length][m[0].length];
  for(int i=0;i<m.length;i++){     // Loop over the rows of the input-matrix
    for(int j=0;j<m[0].length;j++)//  Inner loop over the columns of the input-matrix
      r[i][j]=                    //   Set the corresponding cell in the result-array to:
        Math.max(                 //    The maximum of:
          m[i][j],                //     The current cell in the input-matrix
          m[i][j^1
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 1, 0, 0, 0], [2, 1, 1, 1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 1, 1, 1, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 1, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0]]

