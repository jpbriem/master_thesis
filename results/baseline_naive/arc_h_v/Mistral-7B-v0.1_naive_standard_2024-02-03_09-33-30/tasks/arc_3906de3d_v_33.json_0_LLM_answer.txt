Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 0, 3, 3, 0, 0], [0, 0, 3, 3, 3, 0, 3, 3, 0, 0], [0, 0, 3, 3, 3, 0, 3, 3, 0, 0], [0, 0, 0, 3, 3, 0, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 9, 0, 0, 0, 0], [0, 0, 9, 0, 0, 9, 0, 0, 0, 0]]
output: [[0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 9, 3, 3, 0, 0], [0, 0, 3, 3, 3, 9, 3, 3, 0, 0], [0, 0, 3, 3, 3, 0, 3, 3, 0, 0], [0, 0, 9, 3, 3, 0, 3, 3, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 3, 0, 3, 0, 0], [0, 0, 0, 9, 0, 3, 0, 3, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 0, 0, 0, 0, 9, 0], [0, 0, 9, 9, 0, 0, 0, 0, 9, 0]]
output: [[0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 9, 3, 3, 3, 3, 3, 3, 0], [0, 0, 9, 3, 3, 3, 3, 3, 9, 0], [0, 0, 9, 9, 3, 3, 3, 3, 9, 0], [0, 0, 0, 9, 3, 3, 3, 3, 0, 0], [0, 0, 0, 9, 3, 3, 0, 3, 0, 0], [0, 0, 0, 9, 0, 3, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 0, 3, 3, 0], [0, 0, 3, 3, 3, 3, 0, 3, 3, 0], [0, 0, 0, 3, 3, 3, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 9, 3, 0, 0], [0, 0, 0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 9, 0, 0, 0, 9, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 0, 3, 3, 0], [0, 0, 3, 3, 3, 3, 0, 3, 3, 0], [0, 0, 0, 3, 3, 3, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 9, 3, 0, 0], [0, 0, 0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~78~~ 65 bytes

```
lambda x:[sum(x[:i]+y+x[i+1:])for i,y in enumerate(zip(*x))if y]
```

Try it online!

Comment: `sum(x[:i]+y+x[i+1:])` can be shortened to `sum(x[:i]+y+x[i+1:])`.

Comment: @JonathanAllan Thanks for that! I'm not sure why I didn't think of that...

## Answer (3)

# Jelly, 10 bytes

```
Ḷ€ƇṚ⁵ẎµỤS
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test-suite.

### How?

The first line is a dyadic link taking a list of lists as arguments and returning a list of lists. It uses the fact that if \$n\in\{0,\dots,N-1\}\$, then \$\lfloor n/N\rfloor=0\iff n\equiv 0\pmod N\$.

```
Ḷ€ƇṚ⁵ẎµỤS - Link: list of lists, L
Ḷ€        - length of each row -> [L;L;L;L;L;L;L;L;L;L]
  Ƈ       - filter keep those where:
   Ṛ      -   reverse
    ⁵     -   modulo 5
     Ẏ    -   last two links as a monad - yielding a list of lists
        µ - start a new monadic chain with this result
          - implicit argument, L
         S - sum each row
```

## Answer (3)

# JavaScript (ES6), 54 bytes

Expects an array of arrays. Returns an array of arrays.

```
a=>a.map((_,i)=>(b=[],a.forEach((r,j)=>b+=r[j^i]),b))
```

Try it online!

--------------------

# JavaScript (ES6), 53 bytes

Expects an array of arrays. Returns an array of arrays.

```
a=>a.map((_,i)=>(b=[],a.forEach((r,j)=>b+=r[j%5==i]),b))
```

Try it online!

## Answer (2)

# Haskell, 56 bytes

```
f l=(map(\(_,_,c)->c)<$>transpose<$>filter((/=0).length)$zipWith(++)l<*>replicate 5l)
```

Try it online!

## Answer (2)

# R, ~~64~~ 63 bytes

```
function(x){apply(x,1,function(y)sum(y[seq(0,5,by=5)]))}
```

Try it online!

## Answer (2)

# C++ (gcc), 100 bytes

```
[](auto&a){int b[5];for(int i=0;i<5;i++){for(int j=0;j<a.size();j++)b[i]+=a[j][i];}}
```

Try it online!

## Answer (2)

# Charcoal, 16 bytes

```
ＮθＦθ«Ｅι⊕κ≔⌈⟦⟧Σι✂ικ»≔↨⪫⊖κ⟦⟧
```

Try it online! Link is to verbose version of code. Explanation:

```
Ｎθ
```

Input the number of rows.

```
Ｆθ«
```

Loop over all the rows.

```
Ｅι⊕κ
```

For each column.

```
≔⌈⟦⟧Σι✂ικ
```

Sum up the values in the current row and previous rows.

```
»≔↨⪫⊖κ⟦⟧
```

Output the value in the current column and previous columns.

## Answer (2)

# Retina 0.8.2, 37 bytes

```
O`¶
{`
$*
$*
$*
$*
$*
$*
$*
$*
$*
$*
```

Try it online! Takes input as a single string of characters separated by newlines. Outputs as a single string of characters separated by newlines. Explanation: This is a port of my Java answer.

## Answer (2)

# Ruby, 51 bytes

```
->a{(a.each_with_index{|r,i|r<<r[i]}*"").split}
```

Try it online!

## Answer (2)

# Perl 5, 44 + 1 (-p) = 45 bytes

```
$_=$_;s/(.)/$1.$_[$&]/ge;say
```

Try it online!

## Answer (2)

# Pyth, 10 bytes

```
hQVG@Z5TQ
```

Try it here!

## Answer (2)

# Vyxal, 10 bytes

```
ṗ℅5ṡ‛⍬ṠṘ
```

Try it Online!

## Explained

```
ṗ℅5ṡ‛⍬ṠṘ
ṗ           # Push the input
 ℅5        # Modulo 5
   ṡ        # Sum each element
    ‛⍬     # Push empty string
      Ṡ     # Swap
       Ṙ   # Reverse
```

## Answer (2)

# APL (Dyalog Unicode), 17 bytes^{SBCS}

Anonymous tacit prefix function.

```
{⍵⋄⍳⍴⍵×⍣5⍨⍵}
```

Try it online!

`⍳⍴⍵` generates a vector of indices from 0 to one less than the height of the matrix.

`×⍣5⍨⍵` applies the outer product operator five times to the matrix.

`⍵⋄` returns the original matrix.

## Answer (2)

# MATLAB / Octave, 30 bytes

```
@(a)(a(:)+a(:,end:-1:1)).'
```

Try it online!

## Answer (2)

# Julia, 38 bytes

```
a->[sum(a[:,i])for i=1:5]

################################################################

Solution:
[[0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 9, 3, 3, 0], [0, 0, 3, 3, 3, 3, 9, 3, 3, 0], [0, 0, 9, 3, 3, 3, 9, 3, 0, 0], [0, 0, 0, 0, 3, 0, 9, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

