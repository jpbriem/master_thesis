Input token: 2161
Output token: 2049
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 6, 6, 6, 6, 6], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 6, 6, 6, 6], [9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [9, 9, 9, 0, 0, 0, 6, 6, 6, 6]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 6, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 6, 6, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 6, 6, 6, 6, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [9, 9, 9, 6, 6, 6, 6, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 6], [9, 0, 0, 0, 0, 0, 6, 6, 6, 6], [9, 0, 0, 0, 0, 6, 6, 6, 6, 6], [9, 9, 0, 0, 0, 6, 6, 6, 6, 6], [9, 0, 0, 0, 0, 0, 0, 6, 6, 6], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 6, 6, 6], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 6, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 6, 0, 0, 0, 0], [9, 9, 6, 6, 6, 6, 6, 0, 0, 0], [9, 6, 6, 6, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 6, 6, 6, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 6, 6, 6], [9, 9, 0, 0, 0, 0, 0, 6, 6, 6], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 6, 6, 6, 0, 0, 0, 0, 0, 0], [9, 9, 6, 6, 6, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 6, 6, 6, 6], [9, 0, 0, 0, 0, 0, 6, 6, 6, 6], [9, 9, 0, 0, 0, 0, 0, 0, 6, 6], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 6, 6, 6, 6, 6], [9, 6, 6, 6, 6, 6, 6, 6, 6, 6], [9, 9, 6, 6, 6, 6, 6, 6, 6, 6], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~78~~ 58 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))for j in range(len(a))]for i in range(len(a))]
```

Try it online!

Comment: `min()` is shorter than `sorted()[0]`.

Comment: @JonathanAllan Thanks for the tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 10 bytes

```
Ṛ⁸ŒmƑẎỤṖ€Ṁ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ṛ⁸ŒmƑẎỤṖ€Ṁ - Link: list of lists
Ṛ           - reverse each row
  ⁸         - index into each row at indices 0,1,...,n-1
   Œm       - map over each column:
    Ƒ       -   filter keep those where:
     Ẏ      -     last link (yields 1 iff all elements are truthy)
       Ụ    -   unfilter
       Ṗ€  -   pop off the first element of each row
         Ṁ - maximum
```

## Answer (3)

# JavaScript (ES6), 59 bytes

Expects an array of arrays as input. Returns an array of arrays as output.

```
a=>a.map((r,i)=>r.map((_,j)=>(i&1)?Math.max(...r):Math.min(...r)))
```

Try it online!

### Commented

```
a =>                 // given an array of arrays a[][], return:
a.map(              //   for each row r[] of a[][]:
  (r,               //     r = current row
   i) =>            //     i = current row index
  r.map(            //     for each cell c of r:
    (_ =>           //       return:
      (i & 1)?     //         if i is odd:
        Math.max(...//           take the max of the row
          r)         //         (the spread operator expands the array to its values)
      :            //       else:
        Math.min(...//         take the min of the row
          r)         //         (the spread operator expands the array to its values)
    )               //     end of anonymous function
  )                 //   end of map()
)                   // end of map()
```

## Answer (2)

# Haskell, 56 bytes

```
f x=[[maximum$x!!i|i<-[0..length x-1]]++[minimum$x!!i|i<-[0..length x-1]]]
```

Try it online!

## Answer (2)

# C (gcc), 104 bytes

```
f(int*a){int b=sizeof(*a)/sizeof(**a);return f(b>1?a+b:a)[b/2]+f(b>1?a+b:a)[b/2+1];}
```

Try it online!

## Answer (2)

# R, 54 bytes

```
function(x)t(apply(x,1,cbind,pmin,pmax))
```

Try it online!

## Answer (2)

# Retina 0.8.2, 31 bytes

```
\d
¶
^.*¶
$*
+`(\d)(.)
$1$2
```

Try it online! Explanation:

```
\d
¶
```

Split on digits.

```
^.*¶
$*
```

Remove the leading digit from each line.

```
+`(\d)(.)
$1$2
```

Swap the two characters in each line.

## Answer (2)

# Perl 5, 44 + 1 (-p) = 45 bytes

```
say join"",@F=reverse sort{$_[$_]}0..$#F;$_=$_;s/\d/$&/g
```

Try it online!

## Answer (2)

# Vyxal, 10 bytes

```
ṗ₇ṠṪṡṘṫṄ
```

Try it Online!

Port of @Arnauld's Python answer.

## Explained

```
ṗ₇ṠṪṡṘṫṄ
ṗ₇         # Push the length of the input
  Ṡ        # Swap the top two items on the stack
   Ṫ       # Pop the second item
    ṡ      # Split the remaining item by spaces
     Ṙ     # Reverse each sublist
      ṫ    # Take the head of each sublist
       Ṅ   # Join with newlines
```

## Answer (2)

# Charcoal, 16 bytes

```
ＮθＦθ«≔⊕η⌈ι↨⟦⊞υ⟧⊞υ⟦⊟ι⟧»≔υκ
```

Try it online! Link is to verbose version of code. Outputs using `✱` as a separator. Explanation:

```
Ｎθ
```

Input the number of rows.

```
Ｆθ«
```

Loop over the rows.

```
≔⊕η⌈ι↨⟦⊞υ⟧⊞υ⟦⊟ι⟧
```

Push the maximum and minimum of the row onto the stack.

```
»≔υκ
```

Output the stack joined together with `✱` as a separator.

## Answer (2)

# Ruby, 51 bytes

```
->a{a.map{|r|r.zip([*r].sort).flatten}}
```

Try it online!

## Answer (2)

# APL (Dyalog Unicode), 19 bytes^{SBCS}

Anonymous tacit prefix function.

```
⍳¨⍴⍣⍬⍵⋄⍳¨⍴⍣⍬⍵
```

Try it online!

`⍳¨⍴⍣⍬⍵⋄⍳¨⍴⍣⍬⍵`

Apply this expression twice to the input matrix:

`�
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 0, 0, 0, 0, 0], [9, 6, 6, 6, 6, 0, 0, 0, 0, 0], [9, 9, 6, 6, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

