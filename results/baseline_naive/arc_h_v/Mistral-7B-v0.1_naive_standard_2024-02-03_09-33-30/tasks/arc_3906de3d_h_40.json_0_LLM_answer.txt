Input token: 2161
Output token: 2046
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 6, 6, 6], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 6], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 6, 6, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 6, 0, 0, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 6, 6], [8, 8, 8, 8, 0, 0, 0, 6, 6, 6], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 6], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0, 6], [8, 0, 0, 0, 0, 6, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 6, 6, 0, 0, 0, 0], [8, 8, 8, 8, 6, 6, 6, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 6, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 6, 0, 0, 0, 0, 0, 0], [8, 6, 6, 6, 6, 6, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 6, 6, 6], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0, 6], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 6, 6], [8, 8, 8, 8, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 6, 6, 6, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 6, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 6, 6, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 6, 6, 6], [8, 8, 8, 8, 8, 0, 0, 0, 6, 6], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 6, 6, 6, 6], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 6, 6, 6, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~95~~ 79 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))]for j in range(len(a[0]))]
```

Try it online!

Comment: `min()` is shorter than `sorted()[0]`.

Comment: @JonathanAllan Thanks for that tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 11 bytes

```
Ṛ⁸ŒmƑẎỤṖ€ṀṂ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ṛ⁸ŒmƑẎỤṖ€ṀṂ - Link: list of lists, A
  ⁸          - transpose
   Œm        - map over each row:
    Ƒ        - filter keep:
     Ṛ       - reverse
        Ẏ    - last two links as a dyad:
       Ụ     - unzip
        Ṗ€   - pop off each element of each pair
          Ṁ  - maximum
           Ṃ - minimum
```

## Answer (3)

# JavaScript (ES6), 60 bytes

Expects an array of arrays. Returns an array of arrays.

```
f=([x])=>x,f=(a,b)=>(c=[...a,...b]).map((_,i)=>f(a.map(_=>c[i]),b.map(_=>c[i+a.length])));
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[][] as first argument
) => x,              //   return x if x has only one row
f = (                 // f is a recursive function taking:
  a, b               //   a[][] and b[][] as arguments
) => (                //   return:
  c = [...a,...b]    //     c[][] = concatenation of a and b
).map((_, i) =>       //   for each index i of c:
  f(                  //     call f with:
    a.map(_ => c[i]), //       a[][] mapped to c[i]
    b.map(_ => c[i + a.length]) //     b[][] mapped to c[i + length(a)]
  )                   //   end of map()
);                    // end of f =...
```

## Answer (2)

# Haskell, 61 bytes

```
f l|l==[r]=r|otherwise=f$zipWith max r$zipWith min r$transpose l
```

Try it online!

## Answer (2)

# C++ (gcc), 100 bytes

```
int f(auto&a){return*std::max_element(*a.begin(),*a.end());}main(){int n;scanf("%d",&n);while(n--){int m;scanf("%d",&m);printf("\n");for(int i=0;i<m;i++)for(int j=0;j<n;j++)printf("%d ",f({{a[i][j],a[i][j+n]} }));puts("");}}
```

Try it online!

## Answer (2)

# R, 64 bytes

```
function(x)t(apply(x,1,range)[,2])
```

Try it online!

## Answer (2)

# Retina 0.8.2, 31 bytes

```
\d+
$*
^.*¶
$*
T`(.)(.)
$2$1
```

Try it online! Explanation:

```
\d+
$*
```

Convert all digits to stars.

```
^.*¶
$*
```

Remove newlines.

```
T`(.)(.)
$2$1
```

Swap the characters in each line.

## Answer (2)

# Perl 5, 48 bytes

```
sub f{@_>1&&f(@_[0..$_-1],@_[1..$_]);pop@_}
```

Try it online!

## Answer (2)

# Pyth, 11 bytes

```
hQMzGQMzGQMzG
```

Try it here.

Explanation:

```
hQMzGQMzGQMzG
hQMzGQMzGQMzGQ  Transpose the input twice
             G  Get the maximum value from each column
           zG   Zip together the results
        M       Map over the rows
      Q          Get the minimum value from each row
 h               Head (take the first item)
```

## Answer (2)

# Ruby, 48 bytes

```
->a{(a<<a.reverse).map{|e|e.max}.map(&:min)}
```

Try it online!

## Answer (2)

# Java 8, ~~107~~ 103 bytes

```
a->{var t=new int[a.length];for(int i=0;i<a.length;i++){for(int j=0;j<a[i].length;j++){t[i]+=Math.max(a[i][j],a[i][j+a.length]);}}}
```

Try it online.

**Explanation:**

```
a->{                                                 // Method with integer-array parameter and no return-type
  var t=new int[a.length];                           //  Result-list, initialized with the amount of rows
  for(int i=0;i<a.length;i++){                      //  Loop over every row
    for(int j=0;j<a[i].length;j++){                 //   Inner loop over every cell in this row
      t[i]+=Math.max(a[i][j],a[i][j+a.length]);     //    Add the maximum of the current cell and its counterpart
                                                     //    to the result-list at the current row-index
    }                                               //   End of inner loop (implicit / single-line body)
  }}                                                // End of method
```

## Answer (2)

# Vyxal, 10 bytes

```
ṠṡṗṘṙṛṟ
```

Try it Online!

## Explained

```
ṠṡṗṘṙṛṟ
Ṡ            # Transpose
 ṡ          
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 6, 6, 6, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 6, 6, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 6, 6, 6, 6, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

