Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [9, 9, 9, 9, 9, 9, 9, 0, 9, 0], [9, 9, 9, 9, 9, 9, 0, 0, 9, 0], [9, 9, 9, 9, 0, 0, 0, 0, 9, 0], [0, 9, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 5, 5, 5, 5, 0]]
output: [[9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 0], [9, 9, 9, 9, 9, 9, 9, 5, 9, 0], [9, 9, 9, 9, 9, 9, 5, 5, 9, 0], [9, 9, 9, 9, 0, 5, 5, 0, 9, 0], [0, 9, 0, 9, 0, 5, 0, 0, 5, 0], [0, 0, 0, 9, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 0, 9, 9, 9, 9, 0], [0, 9, 9, 9, 0, 0, 9, 9, 9, 0], [0, 9, 9, 9, 0, 0, 0, 9, 9, 0], [0, 9, 9, 9, 0, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 5, 0, 9, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0]]
output: [[0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 5, 9, 9, 9, 9, 0], [0, 9, 9, 9, 5, 5, 9, 9, 9, 0], [0, 9, 9, 9, 5, 5, 5, 9, 9, 0], [0, 9, 9, 9, 5, 5, 0, 9, 0, 0], [0, 0, 0, 0, 0, 5, 0, 9, 0, 0], [0, 0, 0, 0, 0, 5, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 9, 0, 9, 9, 0, 0], [0, 0, 0, 0, 9, 0, 9, 9, 0, 0], [0, 0, 0, 0, 9, 0, 0, 9, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 0, 5, 0]]
output: [[0, 0, 0, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 5, 9, 9, 9, 9, 5, 0], [0, 0, 0, 5, 9, 9, 9, 9, 5, 0], [0, 0, 0, 5, 9, 5, 9, 9, 5, 0], [0, 0, 0, 0, 9, 0, 9, 9, 0, 0], [0, 0, 0, 0, 9, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 0, 9, 0, 9, 9, 0], [0, 9, 9, 9, 0, 9, 0, 9, 9, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 5, 0, 0, 0], [0, 0, 9, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 5, 0, 5, 0]]
################################################################

LLM answer:

output: [[0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 5, 0, 0, 0], [0, 0, 9, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 5, 0, 5, 0]]
```

## Answer (4)

# Python 3, ~~78~~ 69 bytes

```
lambda x:[[max(x[i][j]for i in range(len(x)))if j<len(x)-1else max(x[i][j+1])for j in range(len(x))]for i in range(len(x))]
```

Try it online!

Comment: `range(len(x))` can be replaced with `range(n)`.

Comment: @JonathanAllan Thanks for the tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 10 bytes

```
Ṗ€⁸ŒmƑẎỤṀṂ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ṗ€⁸ŒmƑẎỤṀṂ - Link: list of lists
Ṗ€         - pop each row from the left
   ⁸       - transpose
    ŒmƑ    - map over each column:
     Ẏ     -   last two links as a dyad f(a,b):
       Ụ   -     unwrap b (remove outermost square brackets)
       Ṁ   -     maximum
         Ṃ - maximum
```

## Answer (3)

# JavaScript (ES6), 53 bytes

Expects an array of arrays. Returns an array of arrays.

```
f=([_,...r]=>(r=[...r].map((c,i)=>(c=[...c].reduce((a,e)=>Math.max(a,e),0)),i++))&&f(r))
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [_,...r] = >       //   r[] = original matrix without its first row
  (                   //
    r = [             //   r[] = new matrix
     ...r            //     copy all rows
     .map((c, i) => ( //     for each row c[]:
        c = [...c]     //       create a copy of c[]
       .reduce((a, e)//       reduce to find the maximum value
          => Math.max(a, e), 0) //       initial value = 0
       , i++          //       increment index i
      )                //     end of map()
    ) &&               //   if r[] is not empty:
      f(r)             //     recurse on r[]
  )                    // end of f()
```

## Answer (2)

# Haskell, 54 bytes

```
import Data.List
p=zipWith(\l r->maximum$zipWith max l r)
g m=(p m!!0):g(transpose m)
```

Try it online!

## Answer (2)

# R, 54 bytes

```
function(x){t(apply(x,1,max));t(apply(t(x),2,max))}
```

Try it online!

## Answer (2)

# C (gcc), 100 bytes

```
f(int*a,int n,int m){for(;--n;)for(int i=0;i<m;)a[i++]>a[n*m+i]||a[n*m+i]=a[i];}
```

Try it online!

## Answer (2)

# Charcoal, 14 bytes

```
ＦθＥι⊞υ⌈κλ≔⪫υ⟦⊕κ↨⊘υ
```

Try it online! Link is to verbose version of code. Explanation:

```
ＦθＥι
```

Loop over the rows.

```
⊞υ⌈κλ
```

Push the maximum element onto the stack.

```
≔⪫υ⟦⊕κ↨⊘υ
```

Pop off the top element and replace it with the next one.

## Answer (2)

# Retina 0.8.2, 27 bytes

```
\d
$&¶
^.*¶
$&
.+
$*
```

Try it online! Link includes test cases. Explanation:

```
\d
$&¶
```

Convert the input into a single line by replacing each digit with itself followed by a newline.

```
^.*¶
$&
```

Replace each line with itself.

```
.+
$*
```

Remove all but the final character from each line.

## Answer (2)

# Ruby, 44 bytes

```
->a{a.map{|r|r.map(&:max)}}
```

Try it online!

## Answer (2)

# Perl 5, 38 + 1 (-p) = 39 bytes

```
say@F=map{$_=pop@F}sort{$a[$_]>$b[$_]}0..$#F
```

Try it online!

## Answer (2)

# Vyxal, 10 bytes

```
ṗ℅ṡṠṚṗ℅ṡṠ
```

Try it Online!

Port of Jonathan Allan's Python answer.

## Explained

```
ṗ℅ṡṠṚṗ℅ṡṠ
ṗ              # Pop the first item
 ℅            # Transpose
  ṡ           # Map over columns
   Ṡ          # Maximum
    Ṛ         # Reverse
     ṗ        # Pop the first item
      ℅       # Transpose
       ṡ      # Map over rows
        Ṡ     # Maximum
```

## Answer (2)

# APL (Dyalog Unicode), 15 bytes^{SBCS}

Anonymous tacit prefix function.

```
⍵/⍳⍴⍵←⍣¨⍳⍴⍵
```

Try it online!

`⍳⍴⍵` generates a vector of indices from 1 to the number of elements in the argument.

`⍣¨⍳⍴⍵` applies that vector to the argument using `⍣`, which means "apply the function to the right" until the result no longer changes. This gives us a vector of vectors where each inner vector contains the maximum values along the corresponding axis.

`⍵/` takes the maximum of those vectors.

`←` assigns this result back to the argument.

`⍴⍵` gets the shape of the argument
################################################################

Solution:
[[0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 9, 0], [0, 9, 9, 9, 5, 9, 5, 9, 9, 0], [0, 9, 9, 9, 5, 9, 5, 9, 9, 0], [0, 0, 9, 0, 5, 0, 5, 0, 5, 0], [0, 0, 9, 0, 0, 0, 5, 0, 0, 0], [0, 0, 9, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

