Input token: 2161
Output token: 2048
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 8, 8, 8], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 8]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 8, 8, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 8, 8, 0, 0, 0, 0], [7, 7, 7, 7, 8, 8, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 8, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [7, 7, 7, 0, 0, 0, 8, 8, 8, 8], [7, 7, 0, 0, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 8], [7, 7, 7, 7, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 8, 8, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [7, 7, 7, 8, 8, 8, 8, 0, 0, 0], [7, 7, 8, 8, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 8, 8, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 8, 0, 0, 0, 0, 0], [7, 7, 7, 7, 8, 8, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 8, 8], [7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [7, 7, 0, 0, 0, 0, 8, 8, 8, 8], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 8, 8, 0, 0, 0], [7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [7, 7, 8, 8, 8, 8, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 8, 8, 8], [7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 8], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 8, 8, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 8, 8], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 8], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~95~~ 94 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))for j in range(len(a))]for i in range(len(a))]
```

Try it online!

Comment: `min()` is shorter than `sorted()[0]`.

Comment: @JonathanAllan Thanks for that tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 6 bytes

```
ḶṪẎỤƊ
```

Try it online!

### How?

```
ḶṪẎỤƊ - Main link. Takes an argument A of shape n x m
Ḷ      - transpose A to get A'. Shape now m x n
  Ẏ    - apply the maximum over each row of A', giving M = [m1,..., mm]. Shape now n
    Ɗ  - last three links as a dyadic chain f(M,A')
  Ụ    -   apply the minimum over each column of A'
Ṫ      -   drop the last element from the result
```

## Answer (3)

# JavaScript (ES6), 54 bytes

Expects a 2D array as input. Returns a 2D array as output.

```
f=([x])=>x,f=(a,b=[],c=[])=>b.push(...a.map((r,y)=>(c[y]=f(r),c))),b
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[][] as first argument
) => x,              //   return x if x is empty
f = (                // f is a recursive function taking:
  a,                 //   a[][] as first argument
  b = [],            //   b[][] as second argument
  c = []             //   c[] as third argument
) =>                 //
b.push(              //   push on b:
 ...a.map((r, y) => //     map r[] over y:
    (c[y] = f(r),    //       set c[y] to the result of calling f with r[]
    c                //       return c
  )                  //   end of map
);                   // end of push
b                    // return b
```

## Answer (3)

# C++ (gcc), 100 bytes

```
int main(){int a[10][10];for(int i=0;i<10;i++)for(int j=0;j<10;j++){scanf("%d",&a[i][j]);}for(int i=0;i<10;i++)for(int j=0;j<10;j++)printf("%d ",a[i][j]>a[i][j+1]?a[i][j]:a[i][j+1]);}
```

Try it online!

## Answer (3)

# Haskell, 64 bytes

```
import Data.List
p=zipWith(\a->maximum$takeWhile(<=a).tail)
f l=transpose$p l>>=id
```

Try it online!

## Answer (3)

# R, ~~64~~ 63 bytes

```
function(x){t(apply(x,1,max)-apply(x,1,min))}
```

Try it online!

## Answer (2)

# Charcoal, 12 bytes

```
Ｎθ≔⁰ηＦθＦθι≔⌈⟦η⟧⟦ι⟧
```

Try it online! Link is to verbose version of code. Explanation:

```
Ｎθ
```

Input the number of rows.

```
≔⁰η
```

Initialise the current row index to zero.

```
ＦθＦθι
```

Loop over all cells.

```
≔⌈⟦η⟧⟦ι⟧
```

Set the cell value to the maximum of its row and column values so far.

## Answer (2)

# Ruby, 51 bytes

```
->a{a.each_with_index{|l,i|l.each_with_index{|e,j|a[i][j]=[e,a[i][j+1]].max}}}
```

Try it online!

## Answer (2)

# Retina 0.8.2, 36 bytes

```
\d
$*
^
$*
.+
$*
```

Try it online! Link includes test cases. Explanation:

```
\d
$*
```

Convert the input to unary.

```
^
$*
```

Transpose the matrix.

```
.+
$*
```

Convert back to decimal.

## Answer (2)

# Perl 5, 49 + 1 (-p) = 50 bytes

```
$_=$_;s/./$F[$_]/ge;say join" ",@F[$_]>$F[$_+1]?@F[$_]:@F[$_+1]for 0..$#F
```

Try it online!

## Answer (2)

# Pyth, 11 bytes

```
hQTGVQTGVQ
```

Try it here!

Explanation:

```
hQTGVQTGVQ
h          Transpose the input
 Q         Map over each row
  T        Take the max of
   G       Each pair of adjacent elements
    VQ     In the row
```

## Answer (2)

# Java 8, ~~107~~ 106 bytes

```
a->{var t=new int[a.length][a[0].length];for(int i=0;i<a.length;i++)for(int j=0;j<a[0].length;j++)t[i][j]=Math.max(a[i][j],a[i][j+1]);return t;}
```

**Explanation:**

Try it online.

```
a->{                           // Method with integer-array parameter and integer-array return-type
  var t=new int[a.length][a[0].length];// Create a new 2D-integer-array with the same size as the input
  for(int i=0;i<a.length;i++)// Loop over the rows of the input
    for(int j=0;j<a[0].length;j++)//  And loop over
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 8, 8, 8, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 0, 0, 0, 0], [7, 7, 7, 7, 8, 8, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [7, 7, 7, 7, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 8, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

