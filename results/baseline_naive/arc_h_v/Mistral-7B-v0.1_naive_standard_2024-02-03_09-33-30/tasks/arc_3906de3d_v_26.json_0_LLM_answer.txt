Input token: 2161
Output token: 2048
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]]
output: [[0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 1, 0, 0], [0, 0, 0, 8, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 0, 8, 8, 8, 0], [0, 8, 8, 8, 8, 0, 8, 0, 8, 0], [0, 8, 8, 8, 8, 0, 8, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 8, 0, 0, 1, 8, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0]]
output: [[0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 1, 8, 8, 8, 0], [0, 8, 8, 8, 8, 1, 8, 1, 8, 0], [0, 8, 8, 8, 8, 1, 8, 1, 8, 0], [0, 0, 8, 1, 0, 1, 8, 0, 1, 0], [0, 0, 8, 1, 0, 0, 8, 0, 1, 0], [0, 0, 8, 1, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 8, 0, 8, 8, 8, 0], [8, 8, 8, 8, 8, 0, 8, 8, 8, 0], [8, 8, 8, 8, 0, 0, 8, 8, 8, 0], [8, 8, 8, 0, 0, 1, 8, 0, 8, 0], [8, 0, 8, 0, 0, 1, 0, 0, 0, 0], [8, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0]]
output: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 8, 1, 8, 8, 8, 0], [8, 8, 8, 8, 8, 1, 8, 8, 8, 0], [8, 8, 8, 8, 1, 1, 8, 8, 8, 0], [8, 8, 8, 0, 0, 1, 8, 0, 8, 0], [8, 0, 8, 0, 0, 1, 0, 0, 1, 0], [8, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 0, 1, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 0, 1, 0, 0]]
```

## Answer (4)

# Python 3, ~~79~~ 65 bytes

```
lambda x:[sum(x[i][j]for i in range(len(x)))<8and x[i][j]or x[i][j]<=8and x[i][j]for j in range(len(x))]
```

Try it online!

Comment: `sum(x[i][j] for i in range(len(x)))<8` can be replaced with `all(x[i][j] for i in range(len(x)))`.

Comment: @KevinCruijssen Thanks! I didn't know that.

## Answer (3)

# Jelly, 11 bytes

```
Ḷ€ƊŒṀ⁼ịẎỤḢ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test-suite.

### How?

The first line is a dyadic link taking a list of lists as arguments and returning a boolean. It returns `True` if all elements of the left argument are less than or equal to those of the right argument.

```
Ḷ€ƊŒṀ⁼ịẎỤḢ - Link: list of lists
Ḷ             - length of each row
 €            - for each...
  Ɗ           -...last two links as a monad:
   ŒṀ         - maximum of each
     ⁼        - equals?
      ị       - index into the left argument
         Ẏ    - flatten
         Ụ    - uniques
           Ḣ  - head
```

## Answer (3)

# JavaScript (ES6), 59 bytes

Expects an array of arrays. Returns an array of booleans.

```
a=>a.map((r,y)=>(r=[...r].sort(),r.every((_,x)=>r[x+1]>r[x]))&&r)
```

Try it online!

### Commented

```
a =>                     // a[] = input array of arrays
a.map((               ) => // map over rows:
  r =>                   //   r = current row
  (                      //   sort the row:
    r = [...r].sort()    //     convert to array and sort
 , y = 0                //   initialize counter at 0
  ) &&                   //   if the following condition holds:
  r                      //     return the sorted row
 .every((_, x) =>       //     for each element x of the row:
    r[x + 1] > r[x])     //       check whether the next element is greater
)                        // end of map()
```

## Answer (2)

# Haskell, 61 bytes

```
f l=(zipWith(\a b->maximum$takeWhile(<=b)$a)l)(transpose l)
```

Try it online!

## Answer (2)

# CJam, 19 bytes

```
q~{_e%}%{_e%}%*
```

Try it online!

## Explanation

```
q~                 " Read input matrix from STDIN.
 {_e%}%            " For each row:
   _e              "   Duplicate the row.
     %             "   Take the modulo by 8.
                   "   This will give us a vector of ones and zeros.
                   "   If there was no number larger than 8, this vector
                   "   will contain only zeroes.
                   "   Otherwise, it will contain some ones.
                   "   We need to find out how many ones we have.
                   "   To do so, we take the modulo by 2.
                   "   This gives us a vector containing either 0 or 1.
                   "   If there were no numbers larger than 8, then
                   "   this vector contains only zeroes.
                   "   Otherwise, it contains some ones.
                   "   So, we count the number of ones.
                   "   If there were any ones, then the number of ones
                   "   must be odd.
                   "   Therefore, we take the modulo by 2 again.
                   "   If the result is nonzero, then there were some
                   "   numbers larger than 8.
                   "   Otherwise, there weren't any such numbers.
 {_e%}%            " End; repeat for every row.
 *                " Multiply the results together.
                   " If there were any numbers larger than 8, then
                   " one of the results would be nonzero.
                   " Thus, the product would also be nonzero.
                   " Otherwise, the product would be zero.
```

## Answer (2)

# Pyth, 10 bytes

```
mQ@TGhQTG
```

Try it here.

Explanation:

```
mQ@TGhQTG Q  # Map over each row
    G       # Get the max value
    hQ      # Get the index of that value
     TG     # Transpose the matrix
 mQ@        # Check if the index is present in the transposed matrix
```

## Answer (2)

# R, ~~60~~ 59 bytes

```
function(x){apply(x,1,function(y)any(y>8&duplicated(y))))
```

Try it online!

## Answer (2)

# Perl 5, 49 bytes

```
sub f{$x=$_[0];map{($x[$_]=grep$_==$x[$_],0..7)[0]}0..$#x}
```

Try it online!

## Answer (2)

# Retina 0.8.2, 37 bytes

```
\d+
$*
^.*¶
$*
1+
$*
1
0
```

Try it online! Link includes test cases. Explanation:

```
\d+
$*
```

Convert each digit to its ASCII code.

```
^.*¶
$*
```

Transpose the matrix.

```
1+
$*
```

Replace runs of digits with their lengths.

```
1
0
```

Replace all remaining digits with `0`.

## Answer (1)

# Charcoal, 16 bytes

```
ＮθＩ≔∧ι⌕θ↨⪫ι⟦⁰…⁷⟧⁴ι
```

Try it online! Link is to verbose version of code. Outputs `1` for true and `0` for false. Explanation:

```
Ｎθ
```

Input the matrix.

```
Ｉ≔∧ι⌕θ↨⪫ι⟦⁰…
################################################################

Solution:
[[0, 0, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 1, 8, 1, 1, 8, 8, 0, 0], [0, 0, 1, 8, 1, 1, 8, 8, 0, 0], [0, 0, 1, 1, 1, 1, 8, 1, 0, 0], [0, 0, 1, 0, 0, 0, 8, 1, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

