Input token: 2161
Output token: 1388
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 3, 3, 3, 3], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3], [9, 9, 0, 0, 0, 0, 3, 3, 3, 3], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 0, 0, 0, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 3, 3, 3, 3, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 0], [9, 9, 9, 3, 0, 0, 0, 0, 0, 0], [9, 9, 3, 3, 3, 3, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 3, 3, 3], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 0, 0, 0, 0, 3, 3], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 3, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 3, 3, 3, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 3, 3, 0, 0, 0, 0, 0], [9, 9, 9, 3, 3, 0, 0, 0, 0, 0], [9, 9, 9, 3, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 0, 3], [9, 9, 0, 0, 0, 0, 0, 3, 3, 3], [9, 9, 9, 0, 0, 0, 0, 3, 3, 3], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 3, 0, 0, 0, 0], [9, 9, 3, 3, 3, 0, 0, 0, 0, 0], [9, 9, 9, 3, 3, 3, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 0, 0, 0, 0, 0, 3, 3, 3], [9, 9, 9, 9, 9, 0, 0, 0, 3, 3], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3], [9, 9, 0, 0, 0, 0, 0, 3, 3, 3], [9, 9, 0, 0, 0, 0, 0, 0, 3, 3], [9, 0, 0, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 0, 0, 0, 3, 3], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 0, 0, 0, 0, 0, 0, 3], [9, 9, 0, 0, 0, 0, 0, 3, 3, 3], [9, 9, 0, 0, 0, 0, 0, 3, 3, 3], [9, 9, 0, 0, 0, 0, 0, 0, 3, 3], [9, 0, 0, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~78~~ 65 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))for j in range(len(a))]for i in range(len(a))]
```

Try it online!

Comment: `min()` is shorter than `sorted()[0]`.

Comment: @JonathanAllan Thanks for the tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 10 bytes

```
Ṗ€⁸ŒmẎỤƊṀṂ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ṗ€⁸ŒmẎỤƊṀṂ - Link: list of lists
Ṗ€         - pop each row from the list of lists
   ⁸       - transpose
    Œm     - main link: list of lists
     Ẏ     - flatten
       Ɗ   - dyadic chain:
         Ṁ  - maximum
          Ṃ - minimum
```

## Answer (3)

# JavaScript (ES6), 54 bytes

Expects an array of arrays as input. Returns an array of arrays.

```
f=([x])=>x,f=(a,b)=>(c=[...a,...b]).map((_,i)=>f(a.map(_=>c[i]),b.map(_=>c[i+a.length])));
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[][] as first argument
) => x,              //   return x if x has only one element
f = (                 // f is a recursive function taking:
  a, b               //   a[][] and b[][] as arguments
) => (               //   return:
  c = [...a,...b]   //     c[][] = concatenation of a and b
).map((_, i) =>      //   map over c with index i:
  f(                 //     call f recursively on:
    a.map(_ =>       //       a[][] mapped to:
      c[i]           //         c[i]
    ),              //     )
    b.map(_ =>       //     call f recursively on:
      c[i + a.length]//       b[][] mapped to:
      c[i + a.length]
    )                //     )
);                   // end of f
```

## Answer (3)

# Haskell, 54 bytes

```
f l|l==[x]=x|otherwise=zipWith(\a b->f$a++b)$f a$f b
```

Try it online!

## Answer (2)

# R, 60 bytes

```
function(x){if(nrow(x)<2)return(x)else{y<-t(x);z<-rbind(x,y);z}}
```

Try it online!

## Answer (2)

# C (gcc), 100 bytes

```
f(int*a,int n,int m){if(!n||!m)return;f(a,n,m-1);f(a+n,m,m-1);}main(){int a[10][10];f(a,10,10);}
```

Try it online!

## Answer (2)

# Charcoal, 12 bytes

```
ＦθＥι≔⌈↨κ⟦⌊↨λ⟧
```

Try it online! Link is to verbose version of code. Explanation:

```
 ＦθＥι
```

Loop over all rows.

```
 ≔⌈↨κ
```

Store the maximum value of the current row.

```
 ⟦⌊↨λ⟧
```

Output the minimum value of the next row.
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 3, 3, 3, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 3, 3, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 0, 0, 0, 0, 0, 0], [9, 9, 9, 3, 0, 0, 0, 0, 0, 0], [9, 9, 3, 3, 3, 0, 0, 0, 0, 0], [9, 9, 3, 3, 0, 0, 0, 0, 0, 0], [9, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

