Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [8, 8, 8, 8, 8, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 0, 8, 8, 0, 0], [8, 0, 8, 0, 8, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 5, 0, 8, 0, 0], [0, 5, 0, 0, 0, 5, 0, 8, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0], [5, 5, 0, 5, 0, 5, 5, 0, 0, 0]]
output: [[8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [8, 8, 8, 8, 8, 5, 8, 8, 0, 0], [8, 8, 8, 8, 8, 5, 8, 8, 0, 0], [8, 5, 8, 5, 8, 5, 5, 8, 0, 0], [5, 5, 0, 0, 0, 5, 0, 8, 0, 0], [0, 5, 0, 0, 0, 5, 0, 8, 0, 0], [0, 5, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 0, 8, 0, 0], [0, 0, 0, 8, 8, 8, 0, 8, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 5, 0], [5, 0, 5, 0, 0, 0, 0, 0, 5, 0], [5, 5, 5, 0, 0, 5, 5, 0, 5, 0]]
output: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [5, 8, 8, 8, 8, 8, 8, 8, 8, 0], [5, 5, 5, 8, 8, 8, 8, 8, 5, 0], [0, 0, 5, 8, 8, 8, 5, 8, 5, 0], [0, 0, 5, 8, 8, 8, 0, 8, 5, 0], [0, 0, 0, 8, 8, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 0, 0, 8, 0, 0, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 5, 0], [0, 0, 0, 0, 0, 5, 0, 0, 5, 0]]
output: [[0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 0, 5, 8, 0, 5, 0], [0, 0, 8, 0, 0, 5, 8, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 0, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 0, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~79~~ 69 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))]for j in range(len(a[0]))]
```

Try it online!

Comment: `min()` is shorter than `sorted()[0]`.

Comment: @JonathanAllan Thanks for that tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 10 bytes

```
Ṛ⁸ŒmƑẎỤṖ€Ṁ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ṛ⁸ŒmƑẎỤṖ€Ṁ - Link: list of lists, A
  ⁸        - transpose
   Œm      - maximum over each row
    Ƒ       - filter by:
    Ẏ       - last link (identity) = identity
        Ṁ  - maximum
          € - for each in the chain:
          Ụ - unfiltered
           Ṗ - pop
```

## Answer (3)

# JavaScript (ES6), 59 bytes

Expects an array of arrays as input. Returns an array of arrays as output.

```
f=([x])=>x,f=(a,b)=>(c=[...a],d=b.map((_,i)=>c[i]=Math.max(...c[i].map(_=>a[i]),...c)),f(d,b))
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[] = initial array of arrays
) => x,              //   return x if x has only one element
f = (                 // f is a recursive function taking:
  a,                 //   a[] = current array of arrays
  b = []             //   b[] = new array of arrays to be returned
) => (               //
  c = [...a],        //   c[] = copy of a[]
  d = b.map((_, i) => //   map b[] with index i to:
    c[i] = Math.max(...c[i].map(_ => a[i]),...c) //     set c[i] to the max value of all elements in c[i] or c[]
  ),                 // end map()
  f(d, b)            //   recurse on d[] and b[]
)                    // end f()
```

## Answer (3)

# Haskell, 58 bytes

```
f l|l==[x]=x|otherwise=zipWith(\a b->maximum$a++b)l$f l
```

Try it online!

## Answer (2)

# R, 61 bytes

```
function(x){while(length(x)>1)x<-apply(x,1,pmax);x}
```

Try it online!

## Answer (2)

# C (gcc), 100 bytes

```
f(int*a,int n,int m){n&&m?(a+=n,f(a,--n,m)):(a[m]=*a,a+=m+1);}
```

Try it online!

## Answer (2)

# Charcoal, 16 bytes

```
ＦθＥι⊞υ⌈⟦⟧κ≔⪫υ⟦⟧κ
```

Try it online! Link is to verbose version of code. Explanation:

```
 ＦθＥι
```

Loop over the rows of the matrix.

```
 ⊞υ⌈⟦⟧κ
```

Push onto the stack the maximum of the current row.

```
 ≔⪫υ⟦⟧κ
```

Pop off the topmost item from the stack and push it back onto the stack. This will have the effect of replacing the previous maximum with the new maximum.

## Answer (2)

# Retina 0.8.2, 31 bytes

```
\d
$*
^
$&
.+
$*
```

Try it online! Takes input as a single line of space separated numbers. Outputs a single line of space separated numbers. Explanation:

```
\d
$*
```

Convert the input into a string of digits.

```
^
$&
```

Prepend the first digit to itself.

```
.+
$*
```

Replace every nonempty substring with its length.

## Answer (2)

# Vyxal, 10 bytes

```
ṗ₴℅ṡṠṘṙṡ
```

Try it Online!

Port of @Arnauld's Python answer.

## Explained

```
ṗ₴℅ṡṠṘṙṡ
ṗ₴℅        # For each column:
 ṡ         #   Take the minimum of the row
  Ṡ        #   Then take the maximum of the row
   Ṙṙ      # Reverse the row
      ṡ    # And take the minimum again
```

## Answer (2)

# Ruby, 51 bytes

```
->a{a.each_with_index{|r,_|r.reverse!;r<<r.pop}}
```

Try it online!

## Answer (2)

# Perl 5, 47 + 1 (-p) = 48 bytes

```
$_=$_;s/./$&$&/ge;s/\G(.)/$1>$&?$1:$&/eg
```

Try it online!

## Answer (2)

# Java 8, ~~107~~ 106 bytes

```
a->{var r=new int[a.length];for(int i=0;i<a.length;i++)for(int j=0;j<a[i].length;j++){r[i]=Math.max(r[i],a[i][j]);}return r;}
```

-1 byte thanks to *@ceilingcat*.

Try it online.

**Explanation:**

```
a->{                                  // Method with integer-array parameter and int-array return-type
  var r=new int[a.length];           //  Result-list, initialized with the amount of rows
  for(int i=0;i<a.length;i++)        //  Loop over the rows
    for(int j=0;
################################################################

Solution:
[[0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 5, 8, 8, 0, 0], [0, 0, 0, 8, 5, 5, 8, 8, 0, 0], [0, 0, 0, 8, 5, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

