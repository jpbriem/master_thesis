Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 0, 8, 0], [0, 0, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 8, 8, 0, 8, 8, 0, 0, 0], [0, 0, 8, 0, 0, 8, 8, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 3, 0, 0], [0, 0, 0, 3, 3, 0, 0, 3, 3, 0], [0, 0, 0, 3, 3, 0, 3, 3, 3, 0]]
output: [[0, 0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 8, 8, 8, 8, 8, 3, 8, 0], [0, 0, 8, 8, 8, 8, 8, 3, 3, 0], [0, 0, 8, 8, 3, 8, 8, 3, 3, 0], [0, 0, 8, 3, 3, 8, 8, 3, 0, 0], [0, 0, 8, 3, 3, 8, 3, 3, 0, 0], [0, 0, 0, 0, 3, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 0, 8, 8, 8, 0, 0], [0, 0, 8, 8, 0, 8, 8, 8, 0, 0], [0, 0, 8, 8, 0, 8, 8, 8, 0, 0], [0, 0, 8, 8, 0, 8, 8, 0, 0, 0], [0, 0, 8, 8, 0, 8, 8, 0, 0, 0], [0, 0, 8, 8, 3, 8, 8, 0, 3, 0], [0, 3, 0, 0, 3, 0, 0, 0, 3, 0], [3, 3, 0, 0, 3, 0, 0, 3, 3, 0], [3, 3, 0, 0, 3, 0, 0, 3, 3, 0]]
output: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 3, 8, 8, 8, 3, 0], [3, 3, 8, 8, 3, 8, 8, 8, 3, 0], [3, 3, 8, 8, 3, 8, 8, 8, 3, 0], [0, 3, 8, 8, 3, 8, 8, 3, 3, 0], [0, 0, 8, 8, 0, 8, 8, 3, 0, 0], [0, 0, 8, 8, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [8, 0, 0, 8, 8, 8, 8, 8, 0, 0], [8, 0, 0, 8, 8, 8, 8, 8, 0, 0], [8, 0, 0, 8, 8, 8, 8, 0, 0, 0], [8, 0, 0, 8, 0, 8, 8, 0, 0, 0], [8, 0, 0, 8, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 3, 3, 0, 0]]
output: [[8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [8, 3, 3, 8, 8, 8, 8, 8, 0, 0], [8, 3, 3, 8, 8, 8, 8, 8, 0, 0], [8, 3, 3, 8, 8, 8, 8, 3, 0, 0], [8, 0, 0, 8, 0, 8, 8, 0, 0, 0], [8, 0, 0, 8, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 0, 8, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 3, 3, 0, 0], [0, 0, 3, 3, 0, 0, 3, 3, 3, 0], [0, 3, 3, 3, 3, 0, 3, 3, 3, 0]]
################################################################

LLM answer:

output: [[0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0]]
```

## Answer (4)

# Python 3, ~~75~~ 69 bytes

```
lambda x:[max(x[:i]+[sum(x[i])]*(len(x)-i),x[i:])for i in range(len(x))]
```

Try it online!

Comment: `sum(x[i])` can be replaced with `x[i].count(8)`.

Comment: @JonathanAllan Thanks for the tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 10 bytes

```
Ḷ€ƇṚ⁵ẎµỤḢ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test-suite.

### How?

The first step is to convert each row into an integer by summing its elements. This is done using the dyadic link `⁵`, e.g.:

```
⁵ 1 2 3 4 5 6 7 8 9 0
  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 0 = 45
```

Then we use the monadic links `Ḷ€` to get all indices where this value occurs more than once. For example:

```
Ḷ€ 45
[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]
```

Next we use the monadic link `Ƈ` to filter out any rows that don't have at least one occurrence of the number. For example:

```
Ƈ 45
[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]
```

Now we reverse the order of the rows so that the largest comes first. We do this using the monadic link `Ṛ`. For example:

```
Ṛ 45
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

Finally we use the monadic link `Ụ` to take the maximum of each pair of adjacent values. For example:

```
Ụ 45
[9, 8, 8, 8, 8, 8, 8, 8, 8, 0]
```

And then we use the monadic link `Ḣ` to return just the first element of the resulting list.

## Answer (3)

# JavaScript (ES6), 64 bytes

Expects an array of arrays as input. Returns an array of arrays.

```
a=>a.map((r,i)=>(r=r.reduce((c,e)=>c+e,0)),a.map(_=>a[i]=r>a[i]?r:a[i]))
```

Try it online!

### Commented

```
a =>                    // a[] = input array of arrays
  a.map((             ) =>     // map over each row r[] of a[]:
    (                ),        //   - initialize r[] to the result of:
      r =              //     -   reduce r[] to its sum
       r.reduce((c,e) => c + e, 0),
    a.map(_ =>          //   - map over the remaining rows of a[], replacing them with:
      a[i] =            //     -   replace the current row a[i][] with:
        r > a[i]? r : a[i] //     -   either r[] if r[] > a[i][], or a[i][] otherwise
    ))
```

## Answer (2)

# Haskell, 64 bytes

```
f l=[maximum$zipWith max l$take n$drop n l|n<-[0..length l]]
```

Try it online!

## Answer (2)

# C++ (clang), ~~107~~ 106 bytes

```
int f(vector<vector<int>>&v){auto m=max_element(begin(v),end(v));return accumulate(m->begin(),m->end(),0)*accumulate(begin(v),end(v),0);}
```

Try it online!

## Answer (2)

# R, 69 bytes

```
function(x)apply(x,1,function(y)max(y,sum(y)))
```

Try it online!

## Answer (2)

# Retina 0.8.2, 37 bytes

```
\d+
$*
^(\d+)(.*)$
$1$2
\G(.)(?=\1)+
$1
```

Try it online! Explanation:

```
\d+
$*
```

Convert each digit to a star.

```
^(\d+)(.*)$
$1$2
```

Split on the longest run of digits.

```
\G(.)(?=\1)+
$1
```

Replace each character with the longest run of characters matching it.

## Answer (2)

# Charcoal, 20 bytes

```
ＮθＦθ«≔⊖ιη≔⌈Σι⟦η⟧»≔↨η⟦η⟧κ
```

Try it online! Link is to verbose version of code. Outputs newline separated strings. Explanation:

```
Ｎθ
```

Input the number of rows.

```
Ｆθ«
```

Loop over the rows.

```
≔⊖ιη
```

Decrement the index.

```
≔⌈Σι⟦η⟧»
```

Find the maximum sum of the previous rows.

```
≔↨η⟦η⟧κ
```

Output the maximum sum of the current row.

## Answer (1)

# Vyxal, 10 bytes

```
ṗ₍ṪṠḋ‛ḣṡṘ
```

Try it Online!

Port of Jonathan Allan's Python answer.

## Explained

```
ṗ₍ṪṠḋ‛ḣṡṘ
ṗ                 # Get the length of the input
 ₍                 # Push a list from 0 to that length
  Ṫ               # Pop off the last item
   Ṡ              # Sum each row
    ḋ             # Find the indices where the sum is greater than 1
     ‛           # Wrap the above in a list
      ḣ           # Flatten the list
        �
################################################################

Solution:
[[0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 3, 8, 8, 3, 3, 3, 0], [0, 8, 3, 3, 3, 8, 3, 3, 3, 0], [0, 8, 3, 3, 0, 8, 3, 3, 0, 0], [0, 8, 0, 0, 0, 0, 0, 3, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

