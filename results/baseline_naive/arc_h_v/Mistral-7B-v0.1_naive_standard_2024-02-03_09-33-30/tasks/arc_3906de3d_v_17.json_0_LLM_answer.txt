Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 7, 7, 0, 7, 7, 7, 0], [0, 0, 0, 7, 7, 0, 7, 7, 7, 0], [0, 0, 0, 0, 7, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0]]
output: [[0, 0, 0, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 7, 7, 7, 7, 7, 7, 0], [0, 0, 0, 7, 7, 2, 7, 7, 7, 0], [0, 0, 0, 7, 7, 2, 7, 7, 7, 0], [0, 0, 0, 0, 7, 2, 7, 7, 7, 0], [0, 0, 0, 0, 2, 2, 0, 7, 7, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 0, 7, 7, 7, 7, 7, 0], [0, 7, 7, 0, 7, 7, 7, 7, 7, 0], [0, 7, 0, 0, 7, 7, 7, 7, 7, 0], [0, 0, 0, 2, 0, 7, 7, 7, 7, 0], [0, 0, 0, 2, 0, 7, 7, 7, 0, 0], [0, 0, 0, 2, 0, 0, 0, 7, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0]]
output: [[0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 2, 7, 7, 7, 7, 7, 0], [0, 7, 7, 2, 7, 7, 7, 7, 7, 0], [0, 7, 2, 2, 7, 7, 7, 7, 7, 0], [0, 0, 0, 2, 0, 7, 7, 7, 7, 0], [0, 0, 0, 2, 0, 7, 7, 7, 0, 0], [0, 0, 0, 2, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 0, 7, 7, 7, 0], [0, 7, 7, 0, 0, 0, 7, 7, 7, 0], [0, 7, 7, 0, 0, 0, 7, 7, 7, 0], [0, 7, 7, 0, 0, 0, 7, 7, 7, 0], [0, 7, 7, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 7, 0, 7, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0]]
output: [[0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 7, 7, 7, 7, 2, 7, 7, 7, 0], [0, 7, 7, 2, 2, 2, 7, 7, 7, 0], [0, 7, 7, 2, 2, 2, 7, 7, 7, 0], [0, 7, 7, 0, 0, 0, 7, 7, 7, 0], [0, 7, 7, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 7, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0], [0, 0, 2, 0, 2, 0, 2, 2, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0], [0, 0, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0], [0, 0, 2, 0, 2, 0, 2, 2, 0, 0]]
```

## Answer (4)

# Python 3, ~~85~~ 69 bytes

```
lambda x:[sum(x[:i]+y+x[i+1:])for i,y in enumerate(zip(*x))if y]
```

Try it online!

Comment: `sum(x[:i]+y+x[i+1:])` can be shortened to `sum(x[:i]+y+x[i+1:])`.

Comment: @JonathanAllan Thanks for that! I'm not sure why I didn't think of that...

## Answer (3)

# Jelly, 10 bytes

```
Ḷ€ƇṚ⁵ẎµỤS
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test-suite.

### How?

The first step is to transpose the matrix using `Ḷ€`, yielding a list of rows. Then we filter out any row with no non-zero elements using `ƇṚ⁵`. This leaves us with a list of rows containing only non-zero elements. We then take the sum of each row using `ẎµỤS`.

## Answer (3)

# JavaScript (ES6), 60 bytes

Expects an array of arrays as input. Returns an array of arrays.

```
a=>a.map((r,i)=>r.filter(_=>!!_)&&r.reduce((c,e)=>(c+=e),0))
```

Try it online!

--------------------

# JavaScript (ES6), 59 bytes

Expects an array of arrays as input. Returns an array of arrays.

```
a=>a.map((r,i)=>r.some(_=>!!_)&&r.reduce((c,e)=>(c+=e),0))
```

Try it online!

## Answer (2)

# Haskell, 54 bytes

```
f l=[sum$l!!<$>[0..length l-1]|elem 0<$>l]
```

Try it online!

## Answer (2)

# R, 54 bytes

```
function(x){apply(x,1,function(y)any(y)&sum(y))}
```

Try it online!

## Answer (2)

# C++ (gcc), 100 bytes

```
[](auto&a){int r=0;for(auto&b:a)for(auto c:b)r+=c;return{r};}
```

Try it online!

## Answer (2)

# Charcoal, 14 bytes

```
ＦθＥιΣκ⊞υ∧κ≔⟦…⌕υ
```

Try it online! Link is to verbose version of code. Explanation:

```
 Ｆθ                   Map over all rows
   Ｅι                For each cell
     Σκ              Sum up all cells above this one
       ⊞υ            Push onto the output stack
         ∧κ          If the current cell was non-zero
            ≔⟦…⌕υ     Replace the top element on the output stack with its index
```

## Answer (2)

# Ruby, 47 bytes

```
->a{(a.map{|r|r.select(&:nonzero?)}.compact).map(&:sum)}
```

Try it online!

## Answer (2)

# Retina 0.8.2, 37 bytes

```
\d
$*
^
$*
+`(\d)(.)
$1$2
```

Try it online! Takes input as a single line of space separated numbers. Outputs newline separated. Explanation:

```
\d
$*
```

Convert all digits to stars.

```
^
$*
```

Remove leading spaces.

```
+`(\d)(.)
$1$2
```

Replace every digit by itself followed by a space.

## Answer (2)

# Perl 5, 44 + 1 (-p) = 45 bytes

```
say join" ",grep/./,$F[$_]=~s/\D//gr
```

Try it online!

## Answer (2)

# Vyxal, 10 bytes

```
ṗ₀∑℅ṡ↲ṠṪ
```

Try it Online!

## Explained

```
ṗ₀∑℅ṡ↲ṠṪ
ṗ           # Transpose the input
 ₀∑         # Sum each column
   ℅       # Filter out empty columns
    ṡ↲     # Sort the remaining columns
      ṠṪ   # Take the last column
```

## Answer (2)

# APL (Dyalog Unicode), 17 bytes^{SBCS}

Anonymous tacit prefix function taking a two dimensional array of integers as left argument.

```
{⍨∘∨∘⊢⍣¨⍳⍴⍵}
```

Try it online!

`⍳⍴⍵` **⍴⍵** returns the number of rows in the input array. `⍳` generates a range from 1 to that number.

`⍳⍴⍵` **⍳⍴⍵** returns the number of columns in the input array. `⍳` generates a range from 1 to that number.

`⍳⍴⍵` **⍳⍴⍵`⍣¨`** applies the function `⍣¨` to both ranges. `⍣¨` takes a vectorized function and a vector of arguments and applies the function to each pair of arguments. In this case, the function is `⍳` again, so the result is a nested list of vectors of indices into the input array.

`⍳⍴⍵` **⍳⍴⍵`⍣¨`⍣¨`∘∨∘⊢`** applies the function `∘∨∘⊢` to each pair of vectors of indices. `∘∨∘⊢` takes a vector of booleans and a vector of values and applies `∨` to each pair of corresponding elements. The result is a nested list of boolean vectors.

`⍳⍴⍵` **⍳⍴⍵`⍣¨`⍣¨`∘∨∘⊢`⍣¨`⍣¨`∘∨∘⊢`⍣¨`∘∨∘⊢
################################################################

Solution:
[[0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 2, 7, 7, 7, 7, 2, 0, 0], [0, 0, 2, 7, 7, 7, 7, 2, 0, 0], [0, 0, 2, 7, 7, 7, 2, 2, 0, 0], [0, 0, 0, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

