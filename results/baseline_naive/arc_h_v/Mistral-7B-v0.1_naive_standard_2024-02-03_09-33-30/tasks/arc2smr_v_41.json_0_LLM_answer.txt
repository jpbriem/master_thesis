Input token: 2119
Output token: 2051
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [3, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 3, 0, 0, 7, 0], [0, 0, 0, 7, 0, 0, 3, 0], [3, 0, 0, 3, 0, 0, 7, 0], [7, 0, 0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0], [3, 0, 0, 3, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0], [3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0], [0, 7, 0, 0, 3, 0], [3, 3, 0, 0, 7, 0], [7, 0, 0, 0, 3, 0], [3, 0, 0, 0, 7, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [3, 0, 0, 0, 0], [0, 0, 0, 3, 0], [3, 0, 0, 0, 0], [0, 0, 0, 3, 0], [3, 3, 0, 0, 0], [0, 0, 0, 3, 0], [3, 3, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 9, 0], [0, 0, 0, 3, 0], [0, 0, 0, 9, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~85~~ 69 bytes

```
lambda a:[sum(a[i][j]for i in range(len(a)))for j in range(len(a))]+[[0]*len(a)]*len(a)
```

Try it online!

Comment: `+[[0]*len(a)]*len(a)` is shorter than `+[[0]*len(a)]*len(a)`.

Comment: @JonathanAllan Thanks for the tip :)

## Answer (3)

# Jelly, 10 bytes

```
Ḷ€ƇṖ⁵ẎỤḢ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test-suite.

### How?

```
Ḷ€ƇṖ⁵ẎỤḢ - Link: list of lists, A
Ḷ          - length of each row
  Ƈ        - filter keep those that:
   Ṗ       -   pop off last element
    ⁵      -   literal 5
     Ẏ     - transpose
      Ụ    - uniques
        Ḣ  - head -> list of lengths
```

## Answer (3)

# JavaScript (ES6), 54 bytes

Expects an array of arrays as input. Returns an array of arrays.

```
f=([x])=>x,f=(a,b)=>(c=[...a],d=b.map((_,i)=>c.push(c.reduce((p,q)=>p+q[i]))),d)
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[] = initial array of arrays
) => x,              // return x if x has only one element
f = (                 // f is a recursive function taking:
  a,                 //   a[] = current array of arrays
  b = []             //   b = empty array to be filled with new rows
) => (               //
  c = [...a],        //   c = copy of a
  d = b.map((_, i) => //   map over b:
    c.push(           //     push a new row at the end of c:
      c.reduce((p, q) => p + q[i]) //       sum all elements of c at index i
    )                 //     end
  ),                 //   end map()
  d                  //   return d
)                    // end f()
```

## Answer (2)

# Haskell, 56 bytes

```
f l|l==[x]=x|t<-transpose l=f$zipWith(+)l t++[0]
```

Try it online!

## Answer (2)

# C (gcc), 104 bytes

```
f(int**a){int**r;if(!*a)return r;r=calloc(*a,sizeof *a);for(int i=0;i<*a;i++)for(int j=0;j<*a;j++){r[i][j]=0;for(int k=0;k<*a;k++)r[i][j]+=a[k][j];}return r;}
```

Try it online!

Returns a pointer to the result matrix.

## Answer (2)

# R, 64 bytes

```
function(m)if(length(m)==1)m else{n<-dim(m)[[1]];m[rep(seq_along(n),each=n),]}
```

Attempt This Online!

## Answer (2)

# Charcoal, 16 bytes

```
ＮθＦθ«ＥθΣκι⊞υ≔⪫υθ»≔υθ
```

Try it online! Link is to verbose version of code. Explanation:

```
Ｎθ
```

Input the number of rows.

```
Ｆθ«
```

Loop over the rows.

```
ＥθΣκι
```

Sum up the values in this column.

```
⊞υ
```

Push the value onto the output stack.

```
≔⪫υθ
```

Repeat the loop until there are no more columns left.

```
»≔υθ
```

Output the final contents of the output stack.

## Answer (2)

# Retina 0.8.2, 31 bytes

```
\d+
$*
^
$&
$
$&
```

Try it online! Takes input as a single line of space separated numbers. Outputs on separate lines. Explanation:

```
\d+
$*
```

Convert the input into a single string of digits.

```
^
$&
```

Prepend the length of the input to the front of the string.

```
$
$&
```

Append the length of the input to the back of the string.

## Answer (2)

# Vyxal, 10 bytes

```
℅ṗ∨⌡₍⟑‛⁰
```

Try it Online!

Takes input as a list of lists.

Explanation:

```
℅ṗ∨⌡₍⟑‛⁰
℅            # Push the length of the first argument
  ṗ          # Zip the first argument with itself
   ∨         # Sum each pair
    ⌡₍       # Transpose
      ⟑      # Map the above lambda
        ‛⁰  # Return 0
```

## Answer (2)

# Ruby, 49 bytes

```
->a{(a+=a.map(&:size)).map{|e|a.map{|r|r.inject(:+,e)}}}+[0]
```

Try it online!

## Answer (2)

# Perl 5, 49 bytes

```
sub f{@_>1&&($_[0].=$_[0].$_[0]).map{$_[0].map{$_+$_[$_]}}}
```

Try it online!

## Answer (2)

# Java 8, 79 bytes

```
a->{var s=new StringBuffer();for(int i=0;i<a.length;i++)s.append(a[i].stream().mapToInt(Integer::valueOf).sum());return Arrays.asList(s.toString(),Arrays.copyOfRange(a,0,a.length));}
```

Try it online!

Port of *@Arnauld*'s answer.

--------------------

# Java 8, 81 bytes

```
a->{var s=new StringBuffer();for(int i=0;i<a.length;i++)s.append(a[i].stream().mapToInt(Integer::valueOf).sum());return Arrays.asList(s.toString(),Arrays.copyOfRange(a,0,a.length));}
```

Try it
################################################################

Solution:
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [3, 0, 0, 0, 0], [7, 0, 0, 3, 0], [3, 0, 0, 7, 0], [7, 0, 0, 3, 0], [3, 3, 0, 7, 0], [7, 7, 0, 3, 0], [3, 3, 0, 7, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

