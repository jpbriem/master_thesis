Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 3, 3], [8, 0, 0, 0, 0, 3, 3, 3, 3, 3], [8, 8, 8, 8, 8, 0, 0, 0, 0, 3], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 0, 0, 0, 3, 3, 3, 3], [8, 8, 8, 8, 0, 0, 0, 0, 3, 3], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 0, 0, 0, 0, 0, 0], [8, 3, 3, 3, 3, 3, 0, 0, 0, 0], [8, 8, 8, 8, 8, 3, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 3, 3, 3, 3, 0, 0, 0], [8, 8, 8, 8, 3, 3, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 3, 3, 3, 3], [8, 8, 8, 8, 0, 0, 0, 0, 3, 3], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 0, 0, 0, 0, 0, 3, 3, 3, 3], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 3, 3, 3], [8, 8, 0, 0, 0, 0, 0, 0, 3, 3]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 3, 3, 3, 3, 0, 0, 0, 0, 0], [8, 8, 8, 8, 3, 3, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 3, 3, 3, 3, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 3, 3, 3, 0, 0, 0, 0, 0], [8, 8, 3, 3, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0, 3], [8, 8, 8, 8, 8, 8, 0, 0, 0, 3], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 3, 3, 3], [8, 0, 0, 0, 0, 0, 0, 3, 3, 3], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 3, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 3, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [8, 3, 3, 3, 0, 0, 0, 0, 0, 0], [8, 3, 3, 3, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 3, 3], [8, 8, 0, 0, 0, 0, 3, 3, 3, 3], [8, 8, 0, 0, 0, 0, 0, 3, 3, 3], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0, 3], [8, 8, 0, 0, 0, 0, 0, 3, 3, 3], [8, 8, 8, 0, 0, 0, 0, 0, 3, 3], [8, 8, 8, 8, 8, 8, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~79~~ 65 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))]for j in range(len(a[0]))]
```

Try it online!

Comment: `min()` is shorter than `sum()/len()`.

Comment: @JonathanAllan Thanks for that tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 10 bytes

```
Ḷ⁼€ƇṚẎỤḢṖ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ḷ⁼€ƇṚẎỤḢṖ - Link: list of lists
Ḷ           - length of each row
   €        - over each row:
   Ƈ        - filter keep those where...
    Ṛ       - reverse
     Ẏ      - yield the last element
        Ụ   - unwrap (remove outermost list)
         Ḣ  - head (first element)
           Ṗ - pop (remove last element)
```

## Answer (3)

# JavaScript (ES6), 54 bytes

Expects an array of arrays as input. Returns an array of arrays as output.

```
f=([x])=>x,f=(a,b)=>(c=[],d=a.map((_,i)=>c.push(f(b[i]))),c)
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[][] as first argument
) => x,              //   return x if x is empty
f = (                 // f is a recursive function taking:
  a, b =             //   a[][] and b[][] as arguments
) => (               //   return:
  c = [],            //     c[][] initialized to [][]
  d = a.map((_, i) => //     map a[][] with index i into:
    c.push(f(b[i]))  //       push the result of calling f on b[i]
  ),                 //     end of map
  c                  //     return c
);                    //   end of function definition
```

## Answer (2)

# Haskell, 49 bytes

```
f l|l==[]=[]|t<-head l=f$tail l++[t]
```

Try it online!

## Answer (2)

# C (gcc), 100 bytes

```
f(int*p){return p&&*p?(p+1)?f(*p):*(p+1):0;};
```

Try it online!

## Answer (2)

# R, 49 bytes

```
function(m)if(!m)m else m[-1]+list(m[1])
```

Attempt This Online!

## Answer (2)

# Charcoal, 10 bytes

```
ＦθＥικ⊞υ⟦⟧
```

Try it online! Link is to verbose version of code. Explanation:

```
 θ        Input array
Ｆ            Map over rows
  ι          Current row
   κ         Index of current row
  ⊞υ         Append to empty array
     ⟦       Opening bracket
       ⟧     Closing bracket
```

## Answer (2)

# Retina 0.8.2, 24 bytes

```
\n¶
$&¶
^.*¶
$&
```

Try it online! Link includes test cases. Explanation:

```
\n¶
$&¶
```

Replace newlines by their corresponding lines.

```
^.*¶
$&
```

Remove all but the first line.

## Answer (2)

# Vyxal, 6 bytes

```
ṗṠṡṀṘ
```

Try it Online!

```
ṗṠṡṀṘ
ṗṠ     # Pop the first item from the stack
  ṡ     # Swap the top two items
   Ṁ    # Push the maximum of the top two items
    Ṙ   # Rotate the stack left
```

## Answer (2)

# Perl 5, 34 + 1 (-p) = 35 bytes

```
$_=$F[$#F];pop@F;say"$_"while@F
```

Try it online!

## Answer (2)

# APL (Dyalog Unicode), 11 bytes^{SBCS}

Anonymous tacit prefix function.

```
{⍵∨⌽⍣≢⍵⋄⍵⍪⍳⍴⍵}
```

Try it online!

`⍵∨⌽⍣≢⍵` Reverse the first element of the matrix. If this is not possible because there is no first element, then we have reached the base case.

`⍵⍪⍳⍴⍵` Prepend the first element of the matrix to itself.

## Answer (2)

# Ruby, 31 bytes

```
->a{(a<<a.shift)*a.size..a}
```

Try it online!

## Answer (2)

# Java 8, 60 bytes

```
a->{var r=new ArrayList<>();r.add(a[0]);for(int[]e:a)r.add(Math.max(e[0],r.get(r.size()-1)));return r;}
```

Try it online.

**Explanation:**

```
a->{                                   // Method with integer-array parameter and int-array return-type
  var r=new ArrayList<>();            //  Result-List, starting empty
  r.add(a[0]);                        //  Add the first value of the input-array to the result-list
  for(int[]e:a)                       //  Loop over every inner-array of the input-array
    r.add(Math.max(e[0],r.get(r.size()-1)));//   Add either the first or second value of the current inner-array
                                       //   to the result-list
  return r;}                         //  Return the result-list
```

## Answer (2)

# Japt, 10 bytes

```
òUìXqVòU
```

Try it

## Answer (2)

# Pyth, 
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 3, 3, 0, 0, 0, 0], [8, 8, 3, 3, 3, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 3, 0, 0, 0, 0, 0, 0], [8, 8, 3, 3, 3, 0, 0, 0, 0, 0], [8, 8, 8, 3, 3, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

