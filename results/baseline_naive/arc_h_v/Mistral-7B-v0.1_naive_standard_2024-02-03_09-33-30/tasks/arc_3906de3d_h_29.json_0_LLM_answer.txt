Input token: 2161
Output token: 2050
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 2], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 2], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 2, 2, 2], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 2, 2, 2, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 2, 2], [6, 0, 0, 0, 0, 0, 2, 2, 2, 2], [6, 6, 6, 6, 6, 0, 0, 0, 0, 2], [6, 6, 6, 6, 6, 0, 0, 0, 0, 2], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 2, 2], [6, 0, 0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 2, 2, 0, 0, 0, 0, 0], [6, 2, 2, 2, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 2, 0, 0, 0, 0], [6, 6, 6, 6, 6, 2, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 2, 2, 0, 0, 0, 0], [6, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 2, 2, 2], [6, 6, 6, 6, 6, 0, 0, 0, 2, 2], [6, 6, 6, 6, 0, 0, 0, 0, 0, 2], [6, 6, 0, 0, 0, 0, 0, 2, 2, 2], [6, 6, 6, 0, 0, 0, 0, 0, 2, 2], [6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 0, 0, 0, 0], [6, 6, 2, 2, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 2, 2, 0, 0, 0], [6, 6, 6, 6, 2, 0, 0, 0, 0, 0], [6, 6, 2, 2, 2, 0, 0, 0, 0, 0], [6, 6, 6, 2, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

Test case:
input: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 2, 2, 2], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 2], [6, 6, 6, 6, 0, 0, 0, 2, 2, 2], [6, 6, 0, 0, 0, 2, 2, 2, 2, 2], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 2, 2, 2, 2], [6, 6, 6, 6, 6, 6, 0, 0, 0, 0]]
################################################################

LLM answer:

output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 2, 2, 2, 2, 2, 2, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 2, 2, 2, 0, 0, 0], [6, 6, 6, 6, 2, 2, 2, 0, 0, 0], [6, 2, 2, 2, 2, 2, 2, 0, 0, 0], [6, 6, 6, 6, 2, 2, 2, 0, 0, 0], [6, 0, 0, 0, 0, 0, 2, 2, 2, 2], [6, 6, 6, 6, 6, 6, 0, 0, 0, 0]]
```

## Answer (4)

# Python 3, ~~95~~ 87 bytes

```
lambda a:[[max(a[i][j]for i in range(len(a)))if j%2else min(a[i][j]for i in range(len(a)))]for j in range(len(a[0]))]
```

Try it online!

Comment: `min()` is shorter than `sum()/len()`.

Comment: @JonathanAllan Thanks for that tip! I've updated my answer accordingly.

## Answer (3)

# Jelly, 11 bytes

```
Ṛ⁸ŒmƑẎỤṖ€ṀṂ
```

A monadic Link accepting a list of lists which yields a list of lists.

**Try it online!** Or see the test suite.

### How?

```
Ṛ⁸ŒmƑẎỤṖ€ṀṂ - Link: list of lists, A
  ⁸          - transpose
   Œm        - map over each row:
    Ƒ        -   filter keepers:
     Ṛ       -     reverse
        Ẏ    - transpose again
        Ụ    - uniqify
           € - for each row:
           Ṁ  - maximum
            Ṃ - minimum
```

## Answer (3)

# JavaScript (ES6), 60 bytes

Expects an array of arrays as input. Returns an array of arrays as output.

```
f=([x])=>x,f=(a,b)=>(c=[...a],d=b.map((_,i)=>c[i]=Math.max(...c[i]),c),f(c,d))
```

Try it online!

### Commented

```
f = (                 // f is a recursive function taking:
  [x]                //   x[] = initial array of arrays
) => x,              //   return x if x has only one element
f = (                 // f is a recursive function taking:
  a,                 //   a[] = current array of arrays
  b = []             //   b[] = new array of arrays to be returned
) => (               //
  c = [...a],        //   c[] = copy of a[]
  d = b.map((_, i) => //   d[] = result of applying the following function to each element of b[]:
    c[i] = Math.max(...c[i]), //     replace the i-th element of c[] with its maximum value
    c                         //     return c[]
  ),                 // end of MAP
  f(c, d)            //   call f recursively on c[] and d[]
)                    // end of f
```

## Answer (2)

# Haskell, 60 bytes

```
f l|l==[r]=r|t<-zipWith max l r=f t++f$zipWith min l r
```

Try it online!

## Answer (2)

# C (gcc), 104 bytes

```
f(int*a){int*p,*q;return p=a,q=a+1,p[0]>q[0]*p[1]<q[1]&&f(p+=2);}
```

Try it online!

## Answer (2)

# R, 64 bytes

```
function(x)do.call("rbind",Map(function(y)matrix(c(max(y),min(y)),nrow=2),x))
```

Try it online!

## Answer (2)

# Retina 0.8.2, 37 bytes

```
\d
¶
^.*¶
$&¶$&
.
$*
```

Try it online! Explanation:

```
\d
¶
```

Split into rows.

```
^.*¶
$&¶$&
```

Duplicate each row.

```
.
$*
```

Replace all characters by their maximum and minimum values respectively.

## Answer (2)

# Perl 5, 49 + 1 (-p) = 50 bytes

```
say join"\n",map{join" ",sort{$a<=>$b}$_[0..$_]}@F
```

Try it online!

## Answer (2)

# Pyth, 12 bytes

```
hQMzG.TQ.TQ
```

Try it online!

## Answer (2)

# Ruby, 49 bytes

```
->a{(a.transpose.map(&:max)+a.transpose.map(&:min)).transpose}
```

Try it online!

## Answer (2)

# Vyxal, 10 bytes

```
ṗ∩⌊↲ṡ⟜℅Ṡ
```

Try it Online!

Port of @Arnauld's JS answer.

## Explained

```
ṗ∩⌊↲ṡ⟜℅Ṡ
ṗ∩⌊↲ṡ⟜℅Ṡ # Implicit input
 ∩           # Transpose
  ⌊          # Minimum along columns
   ↲         # Transpose back
    ṡ        # Split into chunks of size 2
     ⟜       # Zip together
      ℅      # Maximum along rows
        Ṡ    # Swap dimensions
```

## Answer (2)

# Charcoal, 16 bytes

```
ＮθＦθ«≔⪫ι⪪κ⪪λ≔⪫⪪κ⪪λ≔⪫⪪κ⪪λ
```

Try it online! Link is to verbose version of code. Outputs each line separated by a newline. Explanation:

```
Ｎθ
```

Input the number of lines.

```
Ｆθ«
```

Loop over the lines.

```
≔⪫ι⪪κ⪪λ
```

Get the first two elements from the line.

```
≔⪫⪪κ⪪λ
```

Get the last two elements from the line.

```
≔⪫⪪κ⪪λ
```

Get the second two elements from the line.

```
Ｉ
```

Output the line.

## Answer (2)

# Java 8, 100 bytes

```
void m(int[][]a){for(int i=0;i<a.length;i++)for(int j=0;j<a[i].length;j++){System.out.print(Math.max(a[i][
################################################################

Solution:
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 2, 2, 2, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [6, 6, 6, 6, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 2, 2, 2, 0, 0, 0], [6, 6, 2, 2, 2, 2, 2, 0, 0, 0], [6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [6, 2, 2, 2, 2, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 0, 0, 0, 0]]

