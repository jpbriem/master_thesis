Input token: 461
Output token: 1028
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', '.', '.', '.', '.', '.], ['.', '.', '.', '.', 'b', '.], ['.', 'a', '.', '.', '.', '.], ['.', '.', '.', 'e', 'b', '.], ['.', '.', '.', '.', 'b', '.], ['.', '.', '.', '.', '.', 'g']]
output: [['.', '.', '.', '.', '.', '.], ['.', '.', '.', '.', '.', '.], ['.', '.', '.', '.', '.', '.], ['.', '.', '.', '.', 'b', '.], ['.', '.', '.', '.', 'b', '.], ['.', 'a', '.', 'e', 'b', 'g']]

Example_2:
input: [['.', '.', 'c', '.], ['.', 'b', '.', '.], ['a', '.', '.', '.], ['.', '.', '.', '.']]
output: [['.', '.', '.', '.], ['.', '.', '.', '.], ['.', '.', '.', '.], ['a', 'b', 'c', '.']]

Example_3:
input: [['.', '.', '.', 'e], ['c', '.', '.', 'e], ['.', '.', '.', '.], ['c', '.', '.', 'e']]
output: [['.', '.', '.', '.], ['.', '.', '.', 'e], ['c', '.', '.', 'e], ['c', '.', '.', 'e']]

Test case:
input: [['.', '.', '.', 'g', '.], ['i', 'a', 'e', '.', '.], ['i', 'a', '.', 'g', 'd], ['.', 'a', 'e', '.', '.], ['i', '.', '.', 'g', '.']]
################################################################

LLM answer:

output: [['.', '.', '.', '.'], ['.', '.', '.', 'g', '.], ['i', 'a', 'e', '.', '.], ['i', 'a', '.', 'g', 'd'], ['.', 'a', 'e', '.', '.], ['i', '.', '.', 'g', '.']]
"""

import sys
from collections import deque, defaultdict
from typing import List, Optional, Tuple


def get_next(current_state):
    """Returns next state given current state."""
    if len(current_state) == 0:
        return "."
    elif len(current_state) > 4:
        return ".".join([str(x) for x in current_state]) + "."
    else:
        return str(current_state[0]).zfill(5 - len(current_state)) + "."


class StateMachine:
    def __init__(self, initial_state=None):
        self._initial = initial_state or [""]
        self._states = {}
        self._transitions = []

    @property
    def states(self):
        return list(self._states.keys())

    def add_transition(self, source, target, action="", transition_type=""):
        """Add a new transition to the machine."""
        if not isinstance(source, str):
            raise TypeError("Source must be string.")
        if not isinstance(target, str):
            raise TypeError("Target must be string.")
        if not isinstance(action, str):
            raise TypeError("Action must be string.")
        if not isinstance(transition_type, str):
            raise TypeError("Transition type must be string.")
        if transition_type not in ("forward", "backward") and \
                transition_type not in ("left", "right"):
            raise ValueError("Invalid transition type.")
        if transition_type!= "" and (not isinstance(transition_type, tuple)):
            raise TypeError("Transition type must be tuple of two elements.")
        if transition_type!= "" and (len(transition_type) < 2):
            raise IndexError("Transition type must have at least two elements.")
        if transition_type!= "" and (not all((isinstance(t, int) for t in transition_type))):
            raise TypeError("All transition types must be integers.")
        if transition_type!= "" and (not any((t >= 0 for t in transition_type))):
            raise ValueError("All transition types must be nonnegative.")
        if transition_type!= "" and (not any((t <= 9 for t in transition_type))):
            raise ValueError("All transition types must be less than or equal to nine.")
        if transition_type!= "" and (not any((t % 2 == 0 for t in transition_type))):
            raise ValueError("All transition types must be even numbers.")
        if transition_type!= "" and (not any((t // 2 == 0 for t in transition_type))):
            raise ValueError("All transition types must be divisible by two.")
        if transition_type!= "" and (not any((t * 2 == 0 for t in transition_type))):
            raise ValueError("All transition types must be multiple of two.")
        if transition_type!= "" and (not any((t ** 2 == 0 for t in transition_type))):
            raise ValueError("All transition types must be square numbers.")
        if transition_type!= "" and (not any((t ^ 2 == 0 for t in transition_type))):
            raise ValueError("All transition types must be prime numbers.")
        if transition_type!= "" and (not any((t // 3 == 0 for t in transition_type))):
            raise ValueError("All transition types must be divisible by three.")
        if transition_type!= "" and (not any((t // 6 == 0 for t in transition_type))):
            raise ValueError("All transition types must be divisible by six.")
        if transition_type!= "" and (not any((t // 7 == 0 for t in transition_type))):
            raise ValueError("All transition types must be divisible by seven.")
        if transition_type!= "" and (not any((t // 8 == 0 for t in transition_type))):
            raise ValueError("All transition types must be divisible by eight
################################################################

Solution:
[['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['i', 'a', '.', 'g', '.], ['i', 'a', 'e', 'g', '.], ['i', 'a', 'e', 'g', 'd']]

