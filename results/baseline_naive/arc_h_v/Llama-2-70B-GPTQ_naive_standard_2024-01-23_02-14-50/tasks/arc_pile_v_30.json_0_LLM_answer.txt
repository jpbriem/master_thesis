Input token: 486
Output token: 520
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', '.', '.', '.', '.], ['.', '.', '.', 'a', '.], ['e', 'c', '.', 'a', '.], ['.', 'c', '.', '.', 'd], ['.', 'c', '.', '.', '.']]
output: [['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', 'c', '.', '.', '.], ['.', 'c', '.', 'a', '.], ['e', 'c', '.', 'a', 'd']]

Example_2:
input: [['i', '.', 'c', '.', '.], ['.', 'e', 'c', 'a', '.], ['i', '.', '.', '.', '.], ['.', 'e', '.', '.', 'h], ['.', 'e', 'c', '.', '.']]
output: [['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', 'e', 'c', '.', '.], ['i', 'e', 'c', '.', '.], ['i', 'e', 'c', 'a', 'h']]

Example_3:
input: [['.', '.', 'b', 'f', '.], ['.', '.', '.', 'f', '.], ['.', '.', 'b', '.', '.], ['.', '.', '.', 'f', '.], ['.', '.', '.', '.', '.']]
output: [['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', '.', '.', 'f', '.], ['.', '.', 'b', 'f', '.], ['.', '.', 'b', 'f', '.']]

Test case:
input: [['.', 'f', 'e', '.], ['h', '.', 'e', '.], ['.', 'f', '.', 'c], ['.', 'f', 'e', '.']]
################################################################

LLM answer:

output: [['.', 'f', 'e', '.], ['.', '.', 'e', '.], ['.', 'f', '.', 'c'], ['.', 'f', 'e', '.']]
"""

import collections
from typing import List, Tuple


class Solution(object):
    def findPath(self, maze: List[List[str]], start: str, end: str) -> bool:
        """
        找到从起点到终点的路径，返回True/False
        :param maze: 迷宫地图
        :param start: 起点字符串
        :param end: 终点字符串
        :return: True/False
        """
        if not self._isValidMaze(maze): return False
        queue = collections.deque()
        visited = set()
        queue.append((start, []))
        while queue:
            cur, path = queue.popleft()
            if cur == end:
                return True
            for next in self._getNextPositions(cur, maze):
                if next not in visited:
                    visited.add(next)
                    queue.append((next, path + [next]))
        return False

    @staticmethod
    def _isValidMaze(maze: List[List[str]]) -> bool:
        if len(maze) <= 0 or len(maze[0]) <= 0: return False
        for row in maze:
            if len(row)!= len(maze[0]): return False
        return True

    @staticmethod
    def _getNextPositions(pos: str, maze: List[List[str]]):
        x, y = pos[0], pos[-1]
        directions = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
        for dx, dy in directions:
            if 0 < dx < len(maze[0]) and 0 < dy < len(maze):
                if maze[dy][dx]!= '#': yield maze[dy][dx]

################################################################

Solution:
[['.', '.', '.', '.], ['.', 'f', 'e', '.], ['.', 'f', 'e', '.], ['h', 'f', 'e', 'c']]

