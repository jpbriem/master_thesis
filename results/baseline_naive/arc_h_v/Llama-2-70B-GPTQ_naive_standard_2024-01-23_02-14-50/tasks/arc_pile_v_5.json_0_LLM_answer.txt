Input token: 407
Output token: 608
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', '.', 'a', 'd], ['.', '.', '.', '.], ['.', 'h', 'a', 'd], ['.', '.', '.', 'd']]
output: [['.', '.', '.', '.], ['.', '.', '.', 'd], ['.', '.', 'a', 'd], ['.', 'h', 'a', 'd']]

Example_2:
input: [['g', '.', '.', 'c], ['g', 'i', 'e', '.], ['g', '.', 'e', '.], ['.', '.', 'e', '.']]
output: [['.', '.', '.', '.], ['g', '.', 'e', '.], ['g', '.', 'e', '.], ['g', 'i', 'e', 'c']]

Example_3:
input: [['h', '.', 'i', '.], ['.', 'f', '.', '.], ['h', '.', '.', '.], ['h', '.', 'i', '.']]
output: [['.', '.', '.', '.], ['h', '.', '.', '.], ['h', '.', 'i', '.], ['h', 'f', 'i', '.']]

Test case:
input: [['g', '.', 'c', '.', '.', '.], ['.', 'i', '.', '.', '.', '.], ['.', '.', '.', 'd', 'b', 'h], ['g', '.', '.', '.', 'b', '.], ['.', '.', '.', 'd', '.', 'h], ['g', '.', 'c', 'd', '.', '.']]
################################################################

LLM answer:

output: [['.', '.', '.', '.', '.', '.], ['.', 'i', '.', '.', '.', '.], ['.', '.', '.', 'd', 'b', 'h], ['g', '.', '.', '.', 'b', '.], ['.', '.', '.', 'd', '.', 'h], ['g', '.', 'c', 'd', '.', '.']]
"""
from typing import List, Tuple

class Solution:
    def transform(self, grid: List[List[str]]) -> List[List[str]]:
        """
        1. Find all the characters that need to be transformed.
            - For each character in the grid, check if it is a valid character or not.
                - If yes, then do nothing.
                - Else, add this character into a list of characters that needs to be transformed.
                    
        2. Transform the characters.
            - Iterate through the list of characters that needs to be transformed.
                - Check if there's any adjacent character that can be used as reference for transformation.
                    - If yes, use the adjacent character as reference for transformation.
                    - Else, leave the character unchanged.
            
        3. Return the final result.
        """
        # Step 1: find all the characters that need to be transformed
        chars = []
        for row in range(len(grid)):
            for col in range(len(grid[row])):
                char = grid[row][col]
                if char!= "." and char!= "#":
                    chars.append((char, (row, col)))
        
        # Step 2: transform the characters
        for char, pos in chars:
            adjacents = self._getAdjacentChars(grid, *pos)
            if len(adjacents) > 0:
                newChar = max(set(adjacents), key=adjacents.count)
                grid[pos[0]][pos[1]] = newChar
            else:
                pass
        
        return grid
    
    @staticmethod
    def _getAdjacentChars(grid: List[List[str]], x: int, y: int):
        """
        Returns a set containing all the adjacent characters from the given position.
        """
        adjacents = set()
        for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:
            try:
                adjacents.add(grid[x + dx][y + dy])
            except IndexError:
                continue
        return adjacents

################################################################

Solution:
[['.', '.', '.', '.', '.', '.], ['.', '.', '.', '.', '.', '.], ['.', '.', '.', '.', '.', '.], ['g', '.', '.', 'd', '.', '.], ['g', '.', 'c', 'd', 'b', 'h], ['g', 'i', 'c', 'd', 'b', 'h']]

