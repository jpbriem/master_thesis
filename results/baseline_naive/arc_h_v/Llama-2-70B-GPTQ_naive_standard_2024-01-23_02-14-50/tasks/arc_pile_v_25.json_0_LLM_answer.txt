Input token: 352
Output token: 459
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', 'e', '.', '.], ['.', '.', 'a', '.], ['.', 'e', '.', '.], ['.', '.', 'a', 'h']]
output: [['.', '.', '.', '.], ['.', '.', '.', '.], ['.', 'e', 'a', '.], ['.', 'e', 'a', 'h']]

Example_2:
input: [['.', '.', '.', '.], ['i', '.', '.', '.], ['.', 'a', '.', '.], ['.', '.', '.', 'b']]
output: [['.', '.', '.', '.], ['.', '.', '.', '.], ['.', '.', '.', '.], ['i', 'a', '.', 'b']]

Example_3:
input: [['.', '.', '.', '.], ['c', '.', '.', '.], ['c', 'h', '.', '.], ['.', 'h', '.', '.']]
output: [['.', '.', '.', '.], ['.', '.', '.', '.], ['c', 'h', '.', '.], ['c', 'h', '.', '.']]

Test case:
input: [['e', 'g', '.', '.], ['.', '.', '.', 'c], ['.', 'g', 'b', 'c], ['e', 'g', '.', 'c']]
################################################################

LLM answer:

output: [['e', 'g', '.', '.], ['.', '.', '.', 'c'], ['.', 'g', 'b', 'c'], ['e', 'g', '.', 'c']]
"""

# Definition for a Node.
class Node(object):
    def __init__(self, val, isEnd=False):
        self.val = val
        self.isEnd = isEnd
        self.next = []

class Solution(object):
    def orangesSquaring(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: void Do not return anything, modify grid in-place instead.
        """
        
        if len(grid) == 0 or len(grid[0]) == 0:
            return
            
        directions = [(0,-1), (0,1), (-1,0), (1,0)]
        queue = collections.deque()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]!= '.':
                    queue.append((i, j))
                    
        while queue:
            size = len(queue)
            for _ in range(size):
                curPos = queue.popleft()
                posX, posY = curPos[0], curPos[1]
                for direction in directions:
                    newX, newY = posX + direction[0], posY + direction[1]
                    if 0 <= newX < len(grid) and 0 <= newY < len(grid[0]) \
                       and grid[newX][newY] == '.':
                        queue.append((newX, newY))
                        grid[posX][posY] = '.'
                        grid[newX][newY] = '.'
                        
if __name__ == "__main__":
    print("Hello World")
################################################################

Solution:
[['.', '.', '.', '.], ['.', 'g', '.', 'c], ['e', 'g', '.', 'c], ['e', 'g', 'b', 'c']]

