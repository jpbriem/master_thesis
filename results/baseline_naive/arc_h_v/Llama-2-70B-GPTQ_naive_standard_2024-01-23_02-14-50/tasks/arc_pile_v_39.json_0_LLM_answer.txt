Input token: 469
Output token: 880
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', 'b', '.', '.', '.], ['.', 'b', '.', '.', 'e], ['d', '.', 'f', 'a', 'e], ['.', '.', '.', 'a', '.], ['.', 'b', '.', 'a', '.']]
output: [['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', 'b', '.', 'a', '.], ['.', 'b', '.', 'a', 'e], ['d', 'b', 'f', 'a', 'e']]

Example_2:
input: [['b', '.', '.', '.], ['.', '.', '.', '.], ['b', 'a', '.', 'g], ['.', '.', 'f', 'g']]
output: [['.', '.', '.', '.], ['.', '.', '.', '.], ['b', '.', '.', 'g], ['b', 'a', 'f', 'g']]

Example_3:
input: [['.', '.', '.', 'd', 'f], ['b', 'i', '.', 'd', 'f], ['.', '.', '.', 'd', '.], ['.', '.', 'a', '.', '.], ['.', '.', '.', '.', '.']]
output: [['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', '.', '.', 'd', '.], ['.', '.', '.', 'd', 'f], ['b', 'i', 'a', 'd', 'f']]

Test case:
input: [['h', '.', '.', 'a', 'd], ['h', '.', 'i', '.', '.], ['.', '.', 'i', 'a', '.], ['.', 'b', '.', '.', '.], ['.', '.', '.', 'a', '.']]
################################################################

LLM answer:

output: [['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', '.', '.', 'a', '.], ['.', 'b', 'i', 'a', '.], ['h', '.', 'i', 'a', 'd']]
"""
from typing import List, Tuple

class Solution:
    def transform(self, grid: List[List[str]]) -> List[List[str]]:
        """
        1. Find all the "." in the grid that has a neighboring "b".
        2. For each of these ".", find its nearest "b", and replace it with an "a".
        3. Repeat step 2 until there is no more "." to be replaced.
        """
        # Step 0: Initialize variables
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        directions = [(dx, dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]
        b_neighborhoods = [[[] for _ in range(cols)] for __ in range(rows)]
        a_candidates = []

        # Step 1: Find all the "." in the grid that has a neighboring "b".
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == ".":
                    for (dx, dy) in directions:
                        x, y = i + dx, j + dy
                        if 0 <= x < rows and 0 <= y < cols and grid[x][y] == "b":
                            b_neighborhoods[i][j].append((x, y))

        # Step 2: For each of these ".", find its nearest "b", and replace it with an "a".
        while True:
            # Step 2.1: Find the closest "b" from each candidate cell.
            min_distances = {}
            for i in range(rows):
                for j in range(cols):
                    if grid[i][j]!= ".": continue
                    for (x, y) in b_neighborhoods[i][j]:
                        dist = abs(i - x) + abs(j - y)
                        if not min_distances.get((i, j)):
                            min_distances[(i, j)] = dist
                        elif dist < min_distances[(i, j)]:
                            min_distances[(i, j)] = dist
            
            # Step 2.2: Replace the found "b" with "a".
            for (i, j), dist in min_distances.items():
                x, y = i - dist // 2 * sign(i - x), j - dist // 2 * sign(j - y)
                grid[x][y] = "a"

            # Step 2.3: Update neighborhoods.
            for i in range(rows):
                for j in range(cols):
                    if grid[i][j] == ".":
                        for (dx, dy) in directions:
                            x, y = i + dx, j + dy
                            if 0 <= x < rows and 0 <= y < cols and grid[x][y] == "b":
                                b_neighborhoods[i][j].append((x, y))

            # Step 2.4: Check whether we have finished replacing all the cells.
            if not any([cell == "." for row in grid for cell in row]): break

        return grid
    
    @staticmethod
    def sign(num: int) -> int:
        return num / abs(num)

################################################################

Solution:
[['.', '.', '.', '.', '.], ['.', '.', '.', '.', '.], ['.', '.', '.', 'a', '.], ['h', '.', 'i', 'a', '.], ['h', 'b', 'i', 'a', 'd']]

