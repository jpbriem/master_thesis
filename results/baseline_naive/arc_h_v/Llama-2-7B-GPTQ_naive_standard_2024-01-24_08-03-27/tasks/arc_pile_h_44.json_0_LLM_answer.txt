Input token: 558
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['a', 'a', 'a', 'a', 'a', 'a], ['a', 'a', 'a', 'b', 'a', 'a], ['a', 'a', 'a', 'a', 'a', 'a], ['a', 'a', 'f', 'a', 'a', 'a], ['a', 'c', 'c', 'a', 'c', 'a], ['h', 'a', 'a', 'a', 'a', 'a']]
output: [['a', 'a', 'a', 'a', 'a', 'a], ['b', 'a', 'a', 'a', 'a', 'a], ['a', 'a', 'a', 'a', 'a', 'a], ['f', 'a', 'a', 'a', 'a', 'a], ['c', 'c', 'c', 'a', 'a', 'a], ['h', 'a', 'a', 'a', 'a', 'a']]

Example_2:
input: [['a', 'b', 'a', 'a], ['a', 'a', 'c', 'a], ['a', 'a', 'a', 'd], ['a', 'a', 'a', 'a']]
output: [['b', 'a', 'a', 'a], ['c', 'a', 'a', 'a], ['d', 'a', 'a', 'a], ['a', 'a', 'a', 'a']]

Example_3:
input: [['d', 'a', 'd', 'a], ['a', 'a', 'a', 'a], ['a', 'a', 'a', 'a], ['f', 'a', 'f', 'f']]
output: [['d', 'd', 'a', 'a], ['a', 'a', 'a', 'a], ['a', 'a', 'a', 'a], ['f', 'f', 'f', 'a']]

Test case:
input: [['j', 'a', 'j', 'j', 'a], ['a', 'b', 'b', 'b', 'a], ['a', 'f', 'a', 'f', 'a], ['h', 'a', 'h', 'a', 'h], ['a', 'a', 'e', 'a', 'a']]
################################################################

LLM answer:

output: [['j', 'j', 'a', 'a'], ['a', 'b', 'b', 'b', 'a], ['a', 'f', 'a', 'f', 'a], ['h', 'a', 'h', 'a', 'h'], ['a', 'a', 'e', 'a', 'a']]
"""
import sys
from collections import defaultdict, deque
from typing import List, Tuple


def get_input(filename):
    with open(filename) as f:
        return list(map(''.join, map(lambda x: tuple(x), f)))


def get_output(filename):
    with open(filename) + '.out' as f:
        return list(map(''.join, map(lambda x: tuple(x), f)))


def main():
    filename = sys.argv[1] if len(sys.argv) > 1 else "input.txt"
    input_list = get_input(filename)
    output_list = get_output(filename)

    # 0. 입력과 출력의 길이가 다름
    if len(input_list)!= len(output_list):
        print("Input length is different from Output length")
        exit()

    # 1. 패턴을 만들기 위한 전처리
    # 숫자를 제외하고 모든 문자는 대소문자로 구별
    def process_char(chars: str):
        chars = set([ord(i) for i in chars]) - {'0'}
        return sorted(chars)

    def process_line(lines: List[str]):
        lines = [process_char(l) for l in lines]
        return sorted(lines)

    # 2. 패턴 정보를 생성하기 위한 중간단계
    # 암호화된 엑스트라 데이터에서 원래 엑스트라 데이터를 돌아오도록 수정
    def decrypt_extra(encrypted_data: str, extra_data: int):
        encrypted_data += str(extra_data)
        return encrypted_data[:len(encrypted_data)-1]

    def encrypt_extra(decrypted_data: str, extra_data: int):
        decrypted_data += str(extra_data)
        return decrypted_data[:len(decrypted_data)-1]

    # 3. 패턴 정보를 생성하기 위한 마지막단계
    # 최종 패턴은 실제 코드에서 사용될 수 있도록 얻어내기 위해 삭제
    def extract_patterns(input_list: List[Tuple[List[int],...]], output_list: List[Tuple[List[int],...]]):
        patterns = []
        for line in input_list:
            line = process_line(line)
            for char in line:
                if char == '0':
                    continue
                elif char not in ('A', 'B'):
                    break
                else:
                    patterns.append((line, char))
        for line in output_list:
            line = process_line(line)
            for char in line:
                if char == '0':
                    continue
                elif char not in ('A', 'B'):
                    break
                else:
                    patterns.append((line, char))
        return patterns

    # 4. 솔루션 생성
    # 칼럼 개수가 동일한 경우 칼럼 합치기
    def merge_columns(columns: List[Tuple[List[int],...]]):
        columns = [[column[0][0], column[0][1]] for column
################################################################

Solution:
[['j', 'j', 'j', 'a', 'a], ['b', 'b', 'b', 'a', 'a], ['f', 'f', 'a', 'a', 'a], ['h', 'h', 'h', 'a', 'a], ['e', 'a', 'a', 'a', 'a']]

