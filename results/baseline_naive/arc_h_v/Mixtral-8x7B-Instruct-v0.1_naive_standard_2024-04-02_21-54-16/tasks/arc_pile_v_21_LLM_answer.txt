
###########################################################
New Step
###########################################################
prompt_log: Sample Prompt:
Example_1:
input: [['.', 'e', '.', '.', 'd'], ['.', 'e', 'g', '.', 'd'], ['f', '.', '.', '.', '.'], ['.', 'e', '.', 'i', '.'], ['f', '.', '.', '.', 'd']]
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', 'e', '.', '.', 'd'], ['f', 'e', '.', '.', 'd'], ['f', 'e', 'g', 'i', 'd']]

Example_2:
input: [['.', 'h', '.', 'g', '.', '.'], ['c', '.', '.', 'g', '.', '.'], ['.', 'h', 'a', '.', '.', 'i'], ['c', '.', '.', '.', '.', 'i'], ['c', 'h', '.', 'g', '.', '.'], ['.', '.', '.', '.', 'e', 'i']]
output: [['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['c', 'h', '.', 'g', '.', 'i'], ['c', 'h', '.', 'g', '.', 'i'], ['c', 'h', 'a', 'g', 'e', 'i']]

Example_3:
input: [['.', 'g', 'd', '.', 'a'], ['.', '.', '.', '.', 'a'], ['b', '.', 'd', '.', '.'], ['b', 'g', 'd', '.', '.'], ['.', '.', '.', '.', '.']]
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', 'd', '.', '.'], ['b', 'g', 'd', '.', 'a'], ['b', 'g', 'd', '.', 'a']]

Test case:
input: [['c', 'h', 'e', 'i', 'b', 'g'], ['.', '.', 'e', '.', 'b', '.'], ['.', '.', '.', 'i', '.', 'g'], ['.', '.', 'e', 'i', '.', '.'], ['.', '.', '.', '.', 'b', 'g'], ['.', '.', '.', '.', '.', '.']]

###########################################################
Sample Outputs:
output: [['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['c', 'h', 'e', 'i', 'b', 'g']]
*/

// Solution 1:
class Solution {
    public void moveZeroes(int[] nums) {
        int len = nums.length;
        if (len == 0 || len == 1) return;

        // count the number of zero elements in array
        int count = 0;
        for (int i=0; i<len; ++i) {
            if (nums[i] == 0) count++;
        }

        // shift non-zero elements to left side, and fill zeros at right side
        for (int j=0; j<len-count; ++j) {
            if (nums[j]!= 0) continue;
            for (int k=j+1; k<len && nums[k]==0; ++k);
            if (k < len) {
                nums[j] = nums[k];
                nums[k] = 0;
            }
        }
    }
}

// Solution 2:
class Solution {
    public void moveZeroes(int[] nums) {
        int len = nums.length;
        if (len == 0 || len == 1) return;

        // two pointers, one pointer points to first non-zero element, another pointer points to current position
        int p1 = 0, p2 = 0;
        while (p2 < len) {
            if (nums[p2]!= 0) {
                swap(nums, p1++, p2);
            }
            p2++;
        }
    }

    private void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}


###########################################################
Result:
solution: [['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.'], ['.', '.', 'e', 'i', 'b', 'g'], ['.', '.', 'e', 'i', 'b', 'g'], ['c', 'h', 'e', 'i', 'b', 'g']]


success: 0

too_long_prompt: False

tries: 1

success_rate: 0.011320754716981131

cat_success_cnt: 0

cat_success_rate: 0.0

