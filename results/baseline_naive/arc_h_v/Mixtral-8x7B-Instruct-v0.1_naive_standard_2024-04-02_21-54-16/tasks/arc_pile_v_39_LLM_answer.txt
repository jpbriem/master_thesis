
###########################################################
New Step
###########################################################
prompt_log: Sample Prompt:
Example_1:
input: [['.', 'b', '.', '.', '.'], ['.', 'b', '.', '.', 'e'], ['d', '.', 'f', 'a', 'e'], ['.', '.', '.', 'a', '.'], ['.', 'b', '.', 'a', '.']]
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', 'b', '.', 'a', '.'], ['.', 'b', '.', 'a', 'e'], ['d', 'b', 'f', 'a', 'e']]

Example_2:
input: [['b', '.', '.', '.'], ['.', '.', '.', '.'], ['b', 'a', '.', 'g'], ['.', '.', 'f', 'g']]
output: [['.', '.', '.', '.'], ['.', '.', '.', '.'], ['b', '.', '.', 'g'], ['b', 'a', 'f', 'g']]

Example_3:
input: [['.', '.', '.', 'd', 'f'], ['b', 'i', '.', 'd', 'f'], ['.', '.', '.', 'd', '.'], ['.', '.', 'a', '.', '.'], ['.', '.', '.', '.', '.']]
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', 'd', '.'], ['.', '.', '.', 'd', 'f'], ['b', 'i', 'a', 'd', 'f']]

Test case:
input: [['h', '.', '.', 'a', 'd'], ['h', '.', 'i', '.', '.'], ['.', '.', 'i', 'a', '.'], ['.', 'b', '.', '.', '.'], ['.', '.', '.', 'a', '.']]

###########################################################
Sample Outputs:
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', 'a', '.'], ['.', 'b', '.', 'a', '.'], ['h', 'b', 'i', 'a', 'd']]
*/

// Solution 1:
class Solution {
    public void move(int[][] grid, int i, int j) {
        if (grid[i][j] == '.') return;
        char c = grid[i][j];
        grid[i][j] = '.';
        if (i > 0 && grid[i - 1][j]!= '#' && grid[i - 1][j]!= c) move(grid, i - 1, j);
        if (i < grid.length - 1 && grid[i + 1][j]!= '#' && grid[i + 1][j]!= c) move(grid, i + 1, j);
        if (j > 0 && grid[i][j - 1]!= '#' && grid[i][j - 1]!= c) move(grid, i, j - 1);
        if (j < grid[0].length - 1 && grid[i][j + 1]!= '#' && grid[i][j + 1]!= c) move(grid, i, j + 1);
        if (i > 0 && grid[i - 1][j] == c) grid[i - 1][j] = c;
        if (i < grid.length - 1 && grid[i + 1][j] == c) grid[i + 1][j] = c;
        if (j > 0 && grid[i][j - 1] == c) grid[i][j - 1] = c;
        if (j < grid[0].length - 1 && grid[i][j + 1] == c) grid[i][j + 1] = c;
    }

    public List<List<String>> updateBoard(List<List<String>> board, List<List<Integer>> click) {
        int x = click.get(0).get(0), y = click.get(0).get(1);
        if (board.size() <= x || board.get(x).size() <= y || board.get(x).get(y).equals("#")) return board;
        move(boardToIntArray(board), x, y);
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board.get(i).size(); ++j) {
                if (board.get(i).get(j).equals(".")) continue;
                String s = "" + board.get(i).get(j);
                while (s.length() < 2) s += "0";
                board.get(i).set(j, s);
            }
        }
        return board;
    }

    private int[][] boardToIntArray(List<List<String>> board) {
        int n = board.size(), m = board.get(0).size();
        int[][] res = new int[n][m];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                switch (board.get(i).get(j)) {
                    case "#": res[i][j] = '#'; break;
                    case ".": res[i][j] = '.'; break;
                    default: res[i][j] = board.get(i).get(j).charAt(0);
                }
            }
        }
        return res;
    }
}


###########################################################
Result:
solution: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', 'a', '.'], ['h', '.', 'i', 'a', '.'], ['h', 'b', 'i', 'a', 'd']]


success: 0

too_long_prompt: False

tries: 1

success_rate: 0.01056338028169014

cat_success_cnt: 0

cat_success_rate: 0.0

