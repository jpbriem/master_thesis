Input token: 411
Output token: 833
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['i', 'a', 'a', 'a], ['d', 'd', 'd', 'a], ['a', 'a', 'c', 'a], ['a', 'b', 'b', 'a']]
output: [['i', 'a', 'a', 'a], ['d', 'd', 'd', 'a], ['c', 'a', 'a', 'a], ['b', 'b', 'a', 'a']]

Example_2:
input: [['c', 'a', 'a', 'a], ['h', 'a', 'h', 'h], ['a', 'a', 'a', 'a], ['a', 'a', 'a', 'a']]
output: [['c', 'a', 'a', 'a], ['h', 'h', 'h', 'a], ['a', 'a', 'a', 'a], ['a', 'a', 'a', 'a']]

Example_3:
input: [['a', 'e', 'e', 'e], ['b', 'a', 'a', 'a], ['a', 'f', 'f', 'a], ['a', 'a', 'a', 'a']]
output: [['e', 'e', 'e', 'a], ['b', 'a', 'a', 'a], ['f', 'f', 'a', 'a], ['a', 'a', 'a', 'a']]

Test case:
input: [['j', 'a', 'a', 'a], ['a', 'g', 'g', 'g], ['a', 'a', 'f', 'a], ['a', 'd', 'a', 'a']]
################################################################

LLM answer:

output: [['j', 'a', 'a', 'a'], ['a', 'g', 'g', 'a'], ['a', 'a', 'f', 'a'], ['a', 'd', 'a', 'a']]
"""

# Definition for a Node.
class Node(object):
    def __init__(self, val, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def dfs(graph, node, visited):
    """
    :type graph: List[List[Node]]
    :type node: Node
    :rtype: void
    """
    # base condition
    if node in visited: return
    
    # mark current node as visited
    visited.append(node)
    
    # traverse all neighbor nodes of current node
    for nbr in node.neighbors:
        dfs(graph, nbr, visited)
        
    # update value of current node to be the most frequent character among its neighbors
    freq = Counter([nbr.val for nbr in node.neighbors])
    node.val = freq.most_common()[0][0]

def findLargestValue(arr):
    """
    :type arr: List[int]
    :rtype: int
    """
    maxVal = -sys.maxsize - 1
    for i in range(len(arr)):
        currMax = sys.maxsize - 1
        for j in range(len(arr[i])):
            if arr[i][j] > currMax:
                currMax = arr[i][j]
        maxVal = max(currMax, maxVal)
    return maxVal

def buildGraph(grid):
    """
    :type grid: List[List[str]]
    :rtype: List[List[Node]]
    """
    rows = len(grid)
    cols = len(grid[0])
    graph = [[None]*cols for _ in range(rows)]
    for r in range(rows):
        for c in range(cols):
            if (r == 0 or r == rows - 1) or (c == 0 or c == cols - 1): continue
            
            # add top neighbor
            graph[r][c].neighbors.append(graph[r-1][c])
            graph[r-1][c].neighbors.append(graph[r][c])
            
            # add left neighbor
            graph[r][c].neighbors.append(graph[r][c-1])
            graph[r][c-1].neighbors.append(graph[r][c])
                
    return graph

def main():
    """
    :return: void
    """
    # read input from stdin
    grid = list(map(list, map(lambda x: x.strip(), input().split('\n'))))
    print('Input:\n{}'.format(grid))
    
    # build graph
    graph = buildGraph(grid)
    print('Built Graph:\n{}'.format(graph))
    
    # run DFS on each row
    for r in range(len(graph)):
        visited = []
        for c in range(len(graph[r])):
            dfs(graph, graph[r][c], visited)
    
    # print output
    print('Output:\n{}'.format(grid))

if __name__ == "__main__":
    main()
################################################################

Solution:
[['j', 'a', 'a', 'a], ['g', 'g', 'g', 'a], ['f', 'a', 'a', 'a], ['d', 'a', 'a', 'a']]

