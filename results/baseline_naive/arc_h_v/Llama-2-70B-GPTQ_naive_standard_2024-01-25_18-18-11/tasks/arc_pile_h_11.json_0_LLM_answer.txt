Input token: 664
Output token: 789
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 6, 0], [0, 9, 0, 0, 0, 9], [0, 3, 3, 0, 0, 3], [0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0]]
output: [[8, 8, 8, 0, 0, 0], [6, 0, 0, 0, 0, 0], [9, 9, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0]]

Example_2:
input: [[0, 0, 0, 0], [0, 0, 0, 0], [5, 0, 0, 0], [6, 6, 0, 6]]
output: [[0, 0, 0, 0], [0, 0, 0, 0], [5, 0, 0, 0], [6, 6, 6, 0]]

Example_3:
input: [[0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 3], [0, 0, 8, 8, 0, 8], [0, 0, 0, 9, 0, 9], [0, 7, 0, 7, 0, 0], [4, 0, 4, 4, 0, 0]]
output: [[0, 0, 0, 0, 0, 0], [3, 3, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0], [9, 9, 0, 0, 0, 0], [7, 7, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0]]

Test case:
input: [[2, 0, 0, 2, 2], [4, 0, 0, 0, 0], [1, 0, 0, 1, 1], [9, 0, 9, 9, 0], [5, 0, 5, 0, 0]]
################################################################

LLM answer:

output: [[2, 0, 0, 2, 2], [4, 0, 0, 0, 0], [1, 0, 0, 1, 1], [9, 0, 9, 9, 0], [5, 0, 5, 0, 0]]
"""

import numpy as np
from typing import List


class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int) -> List[List[int]]:
        """
        找到最小的矩形，然后遍历每一个元素进行判断是否需要更新。
        :param image:
        :return:
        """
        if not image or not image[0]:
            return []
        m = len(image)
        n = len(image[0])
        minx = maxx = x = y = -1
        for i in range(m):
            for j in range(n):
                if image[i][j] == sr:
                    x = i
                    y = j
                    break
        while True:
            if x < 0 or y < 0:
                break
            if image[x][y]!= sr:
                break
            image[x][y] = sc
            if x > 0 and image[x - 1][y] == sr:
                self._floodfill(image, x - 1, y)
            if y > 0 and image[x][y - 1] == sr:
                self._floodfill(image, x, y - 1)
            if x + 1 < m and image[x + 1][y] == sr:
                self._floodfill(image, x + 1, y)
            if y + 1 < n and image[x][y + 1] == sr:
                self._floodfill(image, x, y + 1)
            x -= 1
            y += 1
        return image

    @staticmethod
    def _floodfill(image, x, y):
        if x >= 0 and x < len(image) and y >= 0 and y < len(image[0]):
            if image[x][y] == image[x][y - 1] \
                    or image[x][y] == image[x - 1][y] \
                    or image[x][y] == image[x + 1][y] \
                    or image[x][y] == image[x][y + 1]:
                image[x][y] = image[x][y - 1] = image[x - 1][y] = image[x + 1][y] = image[x][y + 1] = image[x][y]
                if x > 0 and image[x - 1][y] == image[x][y]:
                    Solution._floodfill(image, x - 1, y)
            else:
                image[x][y] = image[x][y - 1] = image[x - 1][y] = image[x + 1][y] = image[x][y + 1] = image[x][y]

################################################################

Solution:
[[2, 2, 2, 0, 0], [4, 0, 0, 0, 0], [1, 1, 1, 0, 0], [9, 9, 9, 0, 0], [5, 5, 0, 0, 0]]

