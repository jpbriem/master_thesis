Input token: 559
Output token: 1026
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [5, 3, 0, 1, 0], [0, 3, 0, 0, 4], [0, 3, 0, 0, 0]]
output: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 3, 0, 0, 0], [0, 3, 0, 1, 0], [5, 3, 0, 1, 4]]

Example_2:
input: [[9, 0, 3, 0, 0], [0, 5, 3, 1, 0], [9, 0, 0, 0, 0], [0, 5, 0, 0, 8], [0, 5, 3, 0, 0]]
output: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 5, 3, 0, 0], [9, 5, 3, 0, 0], [9, 5, 3, 1, 8]]

Example_3:
input: [[0, 0, 2, 6, 0], [0, 0, 0, 6, 0], [0, 0, 2, 0, 0], [0, 0, 0, 6, 0], [0, 0, 0, 0, 0]]
output: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 6, 0], [0, 0, 2, 6, 0], [0, 0, 2, 6, 0]]

Test case:
input: [[0, 6, 5, 0], [8, 0, 5, 0], [0, 6, 0, 3], [0, 6, 5, 0]]
################################################################

LLM answer:

output: [[0, 6, 5, 0], [8, 0, 5, 0], [0, 6, 0, 3], [0, 6, 5, 0]]
"""

# Definition for a point.
class Point(object):
    def __init__(self, x=None, y=None):
        self.x = x
        self.y = y

def get_neighbors(point, grid):
    neighbors = []
    if point.x > 0:
        neighbors.append((Point(point.x - 1, point.y), grid[point.x - 1][point.y]))
    if point.x < len(grid) - 1:
        neighbors.append((Point(point.x + 1, point.y), grid[point.x + 1][point.y]))
    if point.y > 0:
        neighbors.append((Point(point.x, point.y - 1), grid[point.x][point.y - 1]))
    if point.y < len(grid[0]) - 1:
        neighbors.append((Point(point.x, point.y + 1), grid[point.x][point.y + 1]))
    return neighbors

def find_max_value(row):
    max_val = row[0]
    for i in range(len(row)):
        if row[i] > max_val:
            max_val = row[i]
    return max_val

def floodfill(grid, start):
    queue = [(start.x, start.y)]
    visited = set()
    while queue:
        curr_pos = queue.pop(0)
        curr_pt = Point(*curr_pos)
        if (curr_pt not in visited) and (find_max_value(grid[curr_pt.x]) == grid[curr_pt.x][curr_pt.y]):
            visited.add(curr_pt)
            for neighbor in get_neighbors(curr_pt, grid):
                new_pt = neighbor[0]
                new_val = neighbor[1]
                if new_val!= 0 and new_pt not in visited:
                    queue.append((new_pt.x, new_pt.y))
    return visited

if __name__ == '__main__':
    # Testing code
    test_cases = [[[[0, 6, 5, 0], [8, 0, 5, 0], [0, 6, 0, 3], [0, 6, 5, 0]], [[0, 6, 5, 0], [8, 0, 5, 0], [0, 6, 0, 3], [0, 6, 5, 0]]],
                   [[[0, 0, 2, 6, 0], [0, 0, 0, 6, 0], [0, 0, 2, 0, 0], [0, 0, 0, 6, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 6, 0], [0, 0, 2, 6, 0], [0, 0, 2, 6, 0]]],
                   [[[9, 0, 3, 0, 0], [0, 5, 3, 1, 0], [9, 0, 0, 0, 0], [0, 5, 0, 0, 8], [0, 5, 3, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 5, 3, 0, 0], [9, 5, 3, 0, 0], [9, 5, 3, 1, 8]]],
                   [[[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [
################################################################

Solution:
[[0, 0, 0, 0], [0, 6, 5, 0], [0, 6, 5, 0], [8, 6, 5, 3]]

