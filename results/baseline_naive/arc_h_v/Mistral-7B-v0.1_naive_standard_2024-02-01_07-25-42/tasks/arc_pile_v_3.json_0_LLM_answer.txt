Input token: 464
Output token: 1058
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', '.', 'c', '.', '.'], ['.', '.', '.', '.', '.'], ['.', 'f', '.', '.', '.'], ['a', '.', '.', '.', 'b'], ['.', '.', '.', '.', 'b']]
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'b'], ['a', 'f', 'c', '.', 'b']]

Example_2:
input: [['b', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['b', '.', '.', '.']]
output: [['.', '.', '.', '.'], ['.', '.', '.', '.'], ['b', '.', '.', '.'], ['b', '.', '.', '.']]

Example_3:
input: [['.', 'e', '.', '.', 'c'], ['.', '.', '.', 'i', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', 'e', 'f', '.', 'c']]
output: [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', 'e', '.', '.', 'c'], ['.', 'e', 'f', 'i', 'c']]

Test case:
input: [['h', '.', '.', 'a', '.'], ['.', 'b', 'g', '.', '.'], ['h', '.', 'g', '.', 'i'], ['.', 'b', '.', '.', '.'], ['h', '.', '.', '.', '.']]
################################################################

LLM answer:

output: [['h', '.', '.', '.', '.'], ['.', 'b', 'g', '.', '.'], ['h', '.', 'g', '.', 'i'], ['.', 'b', '.', '.', '.'], ['.', '.', '.', '.', '.']]

Constraints:
1 <= board.length, board[i].length <= 50
board[i][j] is either a lowercase English letter or '.'.
 */
public class SnakeAndLadder {
    public static void main(String[] args) {
        char[][] board = {{'h', '.', '.', 'a', '.'}, {'.', 'b', 'g', '.', '.'}, {'h', '.', 'g', '.', 'i'}, {'.', 'b', '.', '.', '.'}, {'h', '.', '.', '.', '.'}};
        System.out.println(Arrays.deepToString(snakesAndLadders(board)));
    }

    private static int[][] snakesAndLadders(char[][] board) {
        // 1. 找出所有的蛇和梯子，并且记录起点和终点
        List<int[]> ladders = new ArrayList<>();
        List<int[]> snakes = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] =='s') {
                    snakes.add(new int[]{i * 5 + j + 1, i * 5 + j - 4});
                } else if (board[i][j] == 'l') {
                    ladders.add(new int[]{i * 5 + j + 1, i * 5 + j + 6});
                }
            }
        }

        // 2. 计算每个位置到最后一个位置的距离
        int[] distance = new int[board.length * board[0].length];
        Arrays.fill(distance, Integer.MAX_VALUE);
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        distance[0] = 0;
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            for (int next : getNext(cur)) {
                if (next > board.length * board[0].length || distance[next - 1]!= Integer.MAX_VALUE) continue;
                distance[next - 1] = distance[cur - 1] + 1;
                queue.offer(next);
            }
        }

        // 3. 根据蛇和梯子的信息修改距离数组
        for (int[] ladder : ladders) {
            distance[ladder[1] - 1] = distance[ladder[0] - 1];
        }
        for (int[] snake : snakes) {
            distance[snake[1] - 1] = distance[snake[0] - 1];
        }

        return distance;
    }

    /**
     * 获取当前位置可以走的下一步位置
     * @param cur 当前位置
     * @return 下一步位置
     */
    private static Set<Integer> getNext(int cur) {
        Set<Integer> set = new HashSet<>();
        if (cur % 5 == 0 && cur / 5 >= 1) {
            set.add(cur - 4);
        }
        if (cur % 5 == 4 && cur / 5 <= 9) {
            set.add(cur + 1);
        }
        if (cur % 5 == 1 && cur / 5 >= 1) {
            set.add(cur + 1);
        }
        if (cur % 5 == 2 && cur / 5 <= 8) {
            set.add(cur + 1);
        }
        if (cur % 5 == 3 && cur / 5 >= 1) {
            set.add(cur + 1);
        }
        if (cur % 5 == 0 && cur / 5 <= 7) {
            set.add(cur + 1);
        }
        return set;
    }
}
################################################################

Solution:
[['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['h', '.', '.', '.', '.'], ['h', 'b', 'g', '.', '.'], ['h', 'b', 'g', 'a', 'i']]

