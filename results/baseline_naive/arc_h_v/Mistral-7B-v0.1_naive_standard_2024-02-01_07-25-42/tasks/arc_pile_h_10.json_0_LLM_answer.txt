Input token: 553
Output token: 813
################################################################

LLM prompt:
The following input-output pairs are examples and share the same underlying transformation pattern.
Example_1:
input: [['.', '.', '.', 'h', '.', '.'], ['.', 'd', 'd', 'd', '.', '.'], ['.', '.', '.', 'a', '.', '.'], ['.', 'c', '.', '.', '.', '.'], ['.', '.', 'b', '.', '.', '.'], ['.', 'g', '.', '.', 'g', '.']]
output: [['h', '.', '.', '.', '.', '.'], ['d', 'd', 'd', '.', '.', '.'], ['a', '.', '.', '.', '.', '.'], ['c', '.', '.', '.', '.', '.'], ['b', '.', '.', '.', '.', '.'], ['g', 'g', '.', '.', '.', '.']]

Example_2:
input: [['.', '.', '.', '.'], ['i', 'i', 'i', '.'], ['.', '.', '.', '.'], ['d', 'd', '.', 'd']]
output: [['.', '.', '.', '.'], ['i', 'i', 'i', '.'], ['.', '.', '.', '.'], ['d', 'd', 'd', '.']]

Example_3:
input: [['.', '.', '.', '.', '.'], ['.', 'f', '.', '.', 'f'], ['h', '.', 'h', 'h', '.'], ['.', 'g', '.', '.', 'g'], ['.', '.', '.', '.', '.']]
output: [['.', '.', '.', '.', '.'], ['f', 'f', '.', '.', '.'], ['h', 'h', 'h', '.', '.'], ['g', 'g', '.', '.', '.'], ['.', '.', '.', '.', '.']]

Test case:
input: [['.', 'g', '.', '.', 'g', 'g'], ['.', 'c', '.', 'c', 'c', '.'], ['.', 'b', 'b', '.', '.', 'b'], ['.', '.', '.', 'i', 'i', '.'], ['.', '.', '.', 'h', '.', '.'], ['d', '.', '.', 'd', '.', '.']]
################################################################

LLM answer:

output: [['g', '.', '.', '.', 'g', 'g'], ['c', 'c', 'c', '.', '.', '.'], ['b', 'b', '.', '.', '.', 'b'], ['i', 'i', '.', '.', '.', '.'], ['h', '.', '.', '.', '.', '.'], ['d', '.', '.', 'd', '.', '.']]

Constraints:
1 <= board.length, board[i].length <= 50
board[i][j] is either '.' or a lowercase English letter.
 */
public class SnakeAndLadder {
    public static void main(String[] args) {
        int[][] board = {{'g','g'},{'c','c'},{'b','b'},{'i','i'},{'h','h'},{'d','d'}};
        System.out.println(Arrays.deepToString(snakesAndLadders(board)));
    }

    private static int[][] snakesAndLadders(int[][] board) {
        // 1. 找出所有的蛇和梯子，并且记录起点和终点
        List<List<Integer>> snakeAndLadder = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] =='s') {
                    snakeAndLadder.add(new LinkedList<>(Arrays.asList(i + 1, j + 1)));
                } else if (board[i][j] == 'l') {
                    snakeAndLadder.add(new LinkedList<>(Arrays.asList(i + 1, j + 1)));
                }
            }
        }

        // 2. 计算每个位置到最后一个位置的距离
        int[][] distance = new int[board.length * board[0].length][];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                distance[i * board[0].length + j] = new int[]{i, j};
            }
        }

        // 3. 从第一个位置开始遍历，如果遇到蛇或者梯子，则更新当前位置为蛇或者梯子的终点
        Queue<int[]> queue = new ArrayDeque<>();
        queue.offer(distance[0]);
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0];
            int y = cur[1];
            for (List<Integer> snakeOrLadder : snakeAndLadder) {
                if (x == snakeOrLadder.get(0)) {
                    x = snakeOrLadder.get(1);
                } else if (y == snakeOrLadder.get(0)) {
                    y = snakeOrLadder.get(1);
                }
            }
            if (x!= cur[0] || y!= cur[1]) {
                queue.offer(new int[]{x - 1, y});
            }
        }

        return distance;
    }
}
################################################################

Solution:
[['g', 'g', 'g', '.', '.', '.'], ['c', 'c', 'c', '.', '.', '.'], ['b', 'b', 'b', '.', '.', '.'], ['i', 'i', '.', '.', '.', '.'], ['h', '.', '.', '.', '.', '.'], ['d', 'd', '.', '.', '.', '.']]

