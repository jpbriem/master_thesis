LLM prompt:
train input:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 4, 4, 4, 4, 4, 4, 0
0, 0, 0, 4, 4, 4, 4, 4, 4, 0
0, 0, 0, 4, 4, 4, 4, 4, 4, 0
0, 0, 0, 4, 4, 4, 4, 4, 4, 0
train output:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 0, 0, 0, 0, 0
0, 4, 1, 1, 4, 0, 0, 0, 0, 0
0, 4, 1, 1, 4, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 4, 4, 4, 4, 4, 4, 0
0, 0, 0, 4, 2, 2, 2, 2, 4, 0
0, 0, 0, 4, 2, 2, 2, 2, 4, 0
0, 0, 0, 4, 4, 4, 4, 4, 4, 0
End of example.
train input:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 4, 4, 4, 4, 0
0, 0, 0, 0, 0, 4, 4, 4, 4, 0
0, 0, 0, 0, 0, 4, 4, 4, 4, 0
train output:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 4, 2, 2, 2, 4, 0, 0, 0, 0
0, 4, 2, 2, 2, 4, 0, 0, 0, 0
0, 4, 2, 2, 2, 4, 0, 0, 0, 0
0, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 4, 4, 4, 4, 0
0, 0, 0, 0, 0, 4, 1, 1, 4, 0
0, 0, 0, 0, 0, 4, 4, 4, 4, 0
End of example.
test input:
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
test output:
################################################################

LLM answer:

4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
End of example.
```

## C[edit]

This implementation uses a simple binary search tree to store the training data and then performs a depth-first traversal of the tree when classifying new inputs. The code is not optimized for speed or memory usage but should be easy to understand.

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

typedef struct {
    int *data;
    size_t length;
} TreeNode;

TreeNode *tree = NULL;
int numClasses = 0;
double *classWeights = NULL;
size_t maxDepth = 0;

void printTree(TreeNode *node)
{
    if (node == NULL) return;
    printf("%d", node->data[0]);
    for (size_t i=1; i<node->length; ++i)
        printf(", %d", node->data[i]);
    putchar('\n');
    for (size_t i=0; i<numClasses; ++i)
        printTree(node->data[i]? &tree[i] : NULL);
}

void addTrainingData(const double *input, const double *output)
{
    TreeNode **newNodes = malloc(sizeof(*newNodes)*numClasses);
    for (size_t i=0; i<numClasses; ++i)
        newNodes[i] = malloc(sizeof(*newNodes[i])*maxDepth+1);
    for (size_t i=0; i<numClasses; ++i)
        memcpy(&newNodes[i][0], &tree[i][0], sizeof(*newNodes[i]));
    free(tree);
    tree = newNodes;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data = output;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].length = maxDepth + 1;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data[0] = input;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].length++;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data[0] += tree[i].data[0];
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data[0] /= tree[i].length;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data[0] -= tree[i].data[0];
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data[0] *= 1000000000.;
    for (size_t i=0; i<numClasses; ++i)
        tree[i].data[0] /= 1000000
################################################################

Solution:
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
4, 2, 2, 2, 2, 4, 0, 0, 0, 0
4, 2, 2, 2, 2, 4, 0, 0, 0, 0
4, 2, 2, 2, 2, 4, 0, 0, 0, 0
4, 2, 2, 2, 2, 4, 0, 0, 0, 0
4, 4, 4, 4, 4, 4, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 4, 4, 4, 4, 4, 4
0, 0, 0, 0, 4, 1, 1, 1, 1, 4
0, 0, 0, 0, 4, 4, 4, 4, 4, 4

