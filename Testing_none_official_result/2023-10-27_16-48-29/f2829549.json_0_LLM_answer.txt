LLM prompt:
train input:
7, 7, 0, 1, 5, 0, 0
7, 0, 0, 1, 5, 0, 0
0, 0, 0, 1, 5, 0, 5
0, 0, 0, 1, 5, 5, 0
train output:
0, 0, 3
0, 3, 3
0, 3, 0
0, 0, 3
End of example.
train input:
7, 7, 0, 1, 5, 0, 0
0, 0, 0, 1, 0, 0, 0
7, 7, 0, 1, 5, 0, 0
0, 7, 7, 1, 5, 5, 0
train output:
0, 0, 3
3, 3, 3
0, 0, 3
0, 0, 0
End of example.
train input:
0, 7, 7, 1, 5, 0, 0
0, 0, 7, 1, 0, 5, 5
0, 7, 0, 1, 5, 5, 0
0, 0, 7, 1, 0, 0, 0
train output:
0, 0, 0
3, 0, 0
0, 0, 3
3, 3, 0
End of example.
train input:
7, 0, 7, 1, 5, 5, 0
7, 7, 0, 1, 5, 5, 5
0, 7, 0, 1, 0, 0, 0
0, 0, 0, 1, 5, 0, 5
train output:
0, 0, 0
0, 0, 0
3, 0, 3
0, 3, 0
End of example.
train input:
7, 0, 0, 1, 0, 5, 0
0, 0, 7, 1, 5, 0, 0
0, 0, 0, 1, 5, 5, 5
7, 7, 7, 1, 5, 5, 5
train output:
0, 0, 3
0, 3, 0
0, 0, 0
0, 0, 0
End of example.
test input:
0, 0, 0, 1, 0, 5, 0
7, 7, 7, 1, 5, 5, 0
0, 0, 0, 1, 5, 0, 0
7, 0, 0, 1, 5, 5, 5
test output:
################################################################

LLM answer:

0, 0, 0
0, 0, 0
0, 0, 0
0, 0, 0
End of test.
```

## C[edit]

This is a simple implementation that uses the `rand()` function to generate random numbers for each cell in the grid. It then checks if any cells are adjacent and adds them together. If they add up to 10 it prints out the result.

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
    srand((unsigned int) time(NULL));
    int i, j;
    int grid[4][4];
    for (i = 0; i < 4; ++i) {
        for (j = 0; j < 4; ++j) {
            grid[i][j] = rand() % 2 + 1;
        }
    }
    printf("grid:\n");
    for (i = 0; i < 4; ++i) {
        for (j = 0; j < 4; ++j) {
            printf("%d ", grid[i][j]);
        }
        printf("\n");
    }
    for (i = 0; i < 4; ++i) {
        for (j = 0; j < 4; ++j) {
            if ((i > 0 && grid[i - 1][j]) || (i < 3 && grid[i + 1][j])) {
                if ((j > 0 && grid[i][j - 1]) || (j < 3 && grid[i][j + 1])) {
                    if (grid[i][j] == 1) {
                        printf("1\n");
                    } else if (grid[i][j] == 2) {
                        printf("2\n");
                    }
                }
            }
        }
    }
}
```

Output:

```
grid:
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
1
2
1
2
```

## C++[edit]

### Simple solution[edit]

```
#include <iostream>
#include <random>
using namespace std;

constexpr size_t N = 4;

int main() {
    default_random_engine generator{};
    uniform_int_distribution<size_t> distribution{1, 2};
    vector<vector<size_t>> grid(N);
    for (auto& row : grid) {
        row.resize(N);
        for (auto& cell : row) {
            cell = distribution(generator);
        }
    }
    cout << "grid:" << endl;
    for (const auto& row : grid) {
        for (const auto& cell : row) {
            cout << cell <<'';
        }
        cout << endl;
    }
    for (size_t i = 0; i!= N; ++i) {
        for (size_t j = 0; j!= N; ++j) {
            const bool left = (j > 0? grid[i][j-1] : false), right = (j+1 < N? grid[i][j+1] : false), top = (i > 0? grid[i-1][j] : false), bottom = (i+1 < N? grid[i+1][j] : false);
            if (left or right or top or bottom) {
                if (grid[i][j] == 1) {
                    cout << "1" << endl;
                } else if (grid[i][j] == 2) {
                    cout << "2" << endl;
                }
            }
        }
    }
}
```

Output:

```
grid:
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
1
2
1
2
```

### Using a matrix class[edit]

```
#include <iostream>
#include <cmath>
#include <random
################################################################

Solution:
3, 0, 3
0, 0, 0
0, 3, 3
0, 0, 0

