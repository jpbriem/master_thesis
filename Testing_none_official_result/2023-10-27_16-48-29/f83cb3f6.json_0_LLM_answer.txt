LLM prompt:
train input:
0, 0, 5, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 5, 0, 0, 0, 0, 5, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 5
0, 0, 0, 0, 0, 5, 0, 0, 0, 0
5, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 5
8, 8, 8, 8, 8, 8, 8, 8, 8, 8
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 5, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 5, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 5, 0, 0, 0
5, 0, 0, 0, 0, 0, 0, 5, 0, 0
0, 5, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
train output:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
5, 5, 5, 0, 0, 5, 5, 0, 0, 5
8, 8, 8, 8, 8, 8, 8, 8, 8, 8
5, 5, 5, 5, 0, 0, 5, 5, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
End of example.
train input:
0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1
1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 1, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 1, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 1, 0, 0, 0
0, 0, 1, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0
train output:
0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 1, 8, 1, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
End of example.
train input:
0, 0, 2, 0, 0, 2, 0, 0, 0, 0
2, 0, 0, 0, 2, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
2, 0, 0, 0, 0, 0, 0, 0, 0, 2
0, 0, 2, 0, 0, 0, 0, 0, 0, 0
2, 0, 0, 0, 2, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
8, 8, 8, 0, 0, 8, 8, 8, 8, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 2
2, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 2, 0, 2, 0
0, 0, 0, 2, 0, 0, 0, 0, 0, 2
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
train output:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
2, 0, 2, 0, 0, 2, 0, 0, 0, 0
8, 8, 8, 0, 0, 8, 8, 8, 8, 0
2, 0, 0, 0, 0, 0, 2, 0, 2, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
End of example.
test input:
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 3, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3
3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 3, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 3, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 3
test output:
################################################################

LLM answer:

0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 3, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3
3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 3, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 3, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 3
```

## C[edit]

### Recursive descent parser[edit]

This is a recursive descent parser for the language described in the task description. It uses a stack to keep track of the current state and the current token. The grammar is defined as follows:

```
<start> ::= <expr> ';'
<expr> ::= <term> { '+' | '-' } <term>
<term> ::= <factor> { '*' | '/' } <factor>
<factor> ::= NUMBER | '(' <expr> ')'
```

The code is self-explanatory.

```
#include <stdio.h>
#define MAX_TOKENS 16
typedef enum {
    TOKEN_NUMBER = 1,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MULTIPLY,
    TOKEN_DIVIDE,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
} TokenType;
TokenType tokens[MAX_TOKENS];
int top = -1;
void push(TokenType t) {
    if (top == MAX_TOKENS - 1) {
        fprintf(stderr, "Error: too many tokens\n");
        exit(1);
    }
    ++top;
    tokens[top] = t;
}
TokenType pop() {
    if (top == -1) {
        fprintf(stderr, "Error: no more tokens\n");
        exit(1);
    }
    return tokens[top-- --    --    ];
}
void error() {
    fprintf(stderr, "Error: syntax error\n");
    exit(1);
}
void parse();
int main() {
    int c;
    while ((c = getchar())!= EOF && c!= '\n') {
        switch (c) {
            case '+':
                push(TOKEN_PLUS);
                break;
            case '-':
                push(TOKEN_MINUS);
                break;
            case '*':
                push(TOKEN_MULTIPLY);
                break;
            case '/':
                push(TOKEN_DIVIDE);
                break;
            case '(':
                push(TOKEN_LPAREN);
                break;
            case ')':
                push(TOKEN_RPAREN);
               
################################################################

Solution:
0, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 3, 8, 3, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 3, 8, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0

